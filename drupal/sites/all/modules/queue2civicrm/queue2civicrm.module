<?php

use Civi\WMFQueue\DonationQueueConsumer;
use Civi\WMFStatistic\ImportStatsCollector;

function queue2civicrm_batch_process($messageLimit = NULL, $timeLimit = NULL, $wait = FALSE) {
  // We only want to initialize the SmashPig stuff once, so we use the default
  // config section rather than a processor-specific section. This means all
  // processors have to use the same database for pending donation info.
  wmf_common_create_smashpig_context('queue2civicrm');
  wmf_civicrm_boost_performance();

  if (variable_get('queue2civicrm_disable', FALSE)) {
    \Civi::log('wmf')->info('queue2civicrm: Job is disabled.  Exiting.');
    return;
  }

  if (!isset($timeLimit)) {
    $timeLimit = variable_get('queue2civicrm_batch_time', 0);
  }

  // If we're running on a time limit, try to account for drush's startup time.
  if ($timeLimit > 0 && isset($_SERVER['REQUEST_TIME'])) {
    $already_elapsed = time() - $_SERVER['REQUEST_TIME'];
    if ($already_elapsed < $timeLimit) {
      $timeLimit = $timeLimit - $already_elapsed;
    }
  }

  // The number of contributions to process
  if (!$messageLimit) {
    $messageLimit = variable_get('queue2civicrm_batch', 0);
  }
  $consumer = new DonationQueueConsumer(
    'donations',
    $timeLimit,
    $messageLimit,
    (bool) $wait
  );

  $DonationStatsCollector = DonationStatsCollector::getInstance();

  $DonationStatsCollector->startDefaultTimer();
  $processed = $consumer->dequeueMessages();
  $DonationStatsCollector->endDefaultTimer();

  $DonationStatsCollector->addStat('total_messages_dequeued', $processed);

  if ($DonationStatsCollector->exists('message_import_timers')) {
    $DonationStatsCollector->addStat('total_messages_import_time', $DonationStatsCollector->sum('message_import_timers'));
    $DonationStatsCollector->del('message_import_timers');
  }

  $DonationStatsCollector->export();

  // export civicrm import timer stats
  ImportStatsCollector::getInstance()->export();

  /**
   * === Legacy Donations Counter implementation ===
   *
   * Note that this might be a little whack.  At least, it feels a little sloppy.
   * We might consider specifying the names of gateways to keep track of, rather than auto-generate
   * the gateways to keep track of during queue consumption. With the latter (current) method,
   * we'll only report to prometheus when there are > 0 msgs consumed from the queue - meaning if
   * there are no msgs for a particular gateway, that fact will not get reported to prometheus.
   *
   * TODO: metrics stuff should be a hook
   */
  $counter = Queue2civicrmTrxnCounter::instance();
  $metrics = [];
  foreach ($counter->getTrxnCounts() as $gateway => $count) {
    $metrics["${gateway}_donations"] = $count;
  }
  $metrics['total_donations'] = $counter->getCountTotal();
  module_invoke('metrics_reporting', 'report_metrics', 'queue2civicrm', $metrics);
  $ageMetrics = [];
  foreach ($counter->getAverageAges() as $gateway => $age) {
    $ageMetrics["${gateway}_message_age"] = $age;
  }
  module_invoke('metrics_reporting', 'report_metrics', 'donation_message_age', $ageMetrics);

  /**
   * === End of Legacy Donations Counter implementation ===
   */

  if ($processed > 0) {
    \Civi::log('wmf')->notice('queue2civicrm: Successfully processed {processed} contribution(s).', ['processed' => $processed]);
    \Civi::log('wmf')->notice('queue2civicrm: Average Transaction age: {average_age} seconds.', ['average_age' => $DonationStatsCollector->getOverallAverageGatewayTransactionAge()]);
  }
  else {
    \Civi::log('wmf')->notice('queue2civicrm: No contributions processed.');
  }
}
