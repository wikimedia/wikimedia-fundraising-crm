<?php

define('WMF_AUDIT_PAYMENTS_LOGS_DIR', '/usr/local/src/logs/');

/**
 * Counts the missing transactions in the main array of missing transactions.
 * This is annoying and needed its own function, because the $missing array goes
 * $missing[$type]=> array of transactions.
 * Naturally, we're not checking to see that $type is one of the big three that
 * we expect, so it's possible to use this badly. So, don't.
 *
 * @param array $missing An array of missing transactions by type.
 *
 * @return int The total missing transactions in a missing transaction array
 */
function wmf_audit_count_missing($missing) {
  $count = 0;
  if (!is_array($missing) || empty($missing)) {
    return 0;
  }
  foreach ($missing as $type => $data) {
    $count += count($missing[$type]);
  }
  return $count;
}

/**
 * Wrapper for echo
 * Lets us switch on things we only want to see in verbose mode.
 * Also allows us to impose a char limit per line for the benefit of jenkins
 * output logs.
 * Without this, the viz blocks would just ride merrily off the right end of the
 * screen and cause stupid amounts of side scrolling.
 *
 * @staticvar int $chars The number of single chars we've already added to this
 * line.
 * @staticvar int $limit The char limit, set at the command line
 *
 * @param string $echo The thing you want to echo. Single chars will be added to
 * the current line, while longer strings will get their own new line.
 * @param boolean $verbose If true, this message will only appear when we are
 * running in verbose mode. The verbose option is set at the command line.
 *
 * @return null
 */
function wmf_audit_echo($echo, $verbose = FALSE) {
  if (($verbose && wmf_audit_runtime_options('verbose') === FALSE)
    || wmf_audit_runtime_options('quiet')) {
    return;
  }
  static $chars = 0;
  static $limit = NULL;
  if (is_null($limit)) {
    $limit = wmf_audit_runtime_options('charlimit');
  }

  if (strlen($echo) === 1) {
    echo $echo;
    ++$chars;
    if ($limit > 0 && $chars > $limit) {
      echo "\n";
      $chars = 0;
    }
  }
  else {
    //echo a whole line. Gets a little tricky.
    if ($chars != 0) {
      echo "\n";
    }
    echo "$echo\n";
    $chars = 0;
  }
}

/**
 * A confusing function for holding local runtime vars without having to goof
 * around with globals. Works as both get and set, depending on what you pass
 * in
 * with $confusing_thing
 * TODO: Stop that.  Some vars should be global, most should be private to the
 * audit class.
 *
 * @staticvar array $args The arguments set at runtime via drush command
 *
 * @param array|string|null $confusing_thing A confusing thing.
 * * When it is an array, sets the internal static $args variable to that array
 * * When it is a string, it interprets the string to be the key for which
 *   there
 *   should be a value in $args, and returns that value (or false if not
 *   present).
 * * When it is null, it returns the whole $args array.
 *
 * @return mixed Either a boolean, or a specific runtime setting (if
 * $confusing_thing is neither an array nor null)
 */
function wmf_audit_runtime_options($confusing_thing = NULL) {
  if (!isset(\Civi::$statics['wmf_audit_runtime'])) {
    \Civi::$statics['wmf_audit_runtime'] = [];
  }
  if (is_array($confusing_thing)) { //we're setting up the function for later use, and $confusing_thing is the array of current settings.
    \Civi::$statics['wmf_audit_runtime'] = $confusing_thing;
    return TRUE;
  }
  elseif (is_null($confusing_thing)) { //we want all the settings
    return \Civi::$statics['wmf_audit_runtime'];
  }
  elseif (array_key_exists($confusing_thing, \Civi::$statics['wmf_audit_runtime'])) { //we are after a specific setting
    return \Civi::$statics['wmf_audit_runtime'][$confusing_thing];
  }
  return FALSE;
}

/**
 * Logs the errors we get in a consistent way
 *
 * @deprecated call $this->logError() on Audit classes.
 *
 * @param string $message The message we want to log. Should be
 * descriptive enough that we can bug hunt without having to go all cowboy in
 * prod.
 * @param string $drush_code If this code is fatal (According to
 * wmf_audit_error_isfatal), this will result in the whole script dying.
 */
function wmf_audit_log_error($message, $drush_code) {

  \Civi::log('wmf')->error(wmf_audit_runtime_options('submod_prefix') . '_audit: {message}',
    ['message' => $message]);

  //Maybe explode
  if (wmf_audit_error_isfatal($drush_code)) {
    die("\n*** Fatal Error $drush_code: $message");
  }
}

/**
 * Returns an array of errors that should not cause the script to blow up, but
 * which will probably still cause messages to get thrown out.
 * TODO: Use WMFException instead.
 *
 * @return boolean true if the error code is fatal, otherwise false.
 */
function wmf_audit_error_isfatal($error) {
  //All of these "nonfatal" things are meant to be nonfatal to the *job*, and
  //not nonfatal to the contribution itself. We hit one of these,
  //the contribution will be skipped, and we move to the next one.
  //ALL OTHER CODES will cause the process to come to a screeching halt.
  $nonfatal = [
    'DATA_INCONSISTENT',
    'DATA_INCOMPLETE',
    'DATA_WEIRD',
    'MISSING_PAYMENTS_LOG',
    'MISSING_MANDATORY_DATA',
    'UTM_DATA_MISMATCH',
    'NORMALIZE_DATA',
  ];

  if (in_array($error, $nonfatal)) {
    return FALSE;
  }
  else {
    return TRUE;
  }
}
