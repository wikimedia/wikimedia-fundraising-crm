<?php
// include common functions
require_once( drupal_get_path( 'module', 'recurring_globalcollect' ) . '/recurring_globalcollect_common.inc' );

/**
 * Implementation of hook_menu().
 */
function recurring_globalcollect_menu() {
  $items = array();
  
  $items['admin/settings/recurring_globalcollect'] = array(
    'title' => 'Recurring GlobalCollect Processor',
    'description' => t('Configure message queue interface.'),
    'access arguments' => array('administer recurring_globalcollect'),
    'page callback' => 'drupal_get_form',
    'page arguments' => array('recurring_globalcollect_settings'),
  );

  $items['admin/settings/recurring_globalcollect/configure'] = array(
    'title' => 'Configure',
    'access arguments' => array('administer recurring_globalcollect'),
    'type' => MENU_DEFAULT_LOCAL_TASK,
  );

  $items['admin/settings/recurring_globalcollect/search'] = array(
    'title' => 'Search',
    'access arguments' => array('administer recurring_globalcollect'),
    'page callback' => 'drupal_get_form',
    'page arguments' => array('recurring_globalcollect_search_by_order_id_form'),
    'type' => MENU_LOCAL_TASK,
  );

  $items['admin/settings/recurring_globalcollect/test'] = array(
    'title' => 'Test',
    'access arguments' => array('administer recurring_globalcollect'),
    'page callback' => 'recurring_globalcollect_test',
    'type' => MENU_LOCAL_TASK,
  );
  
  $items['recurring_globalcollect'] = array(
    'access callback' => TRUE,
    'type' => MENU_CALLBACK,
    'page callback' => 'recurring_globalcollect_batch_process',
  );
  
  return $items;
}

function recurring_globalcollect_test() {

  $return = 'No testing available at this time.';
  return $return;
}
/**
 * Implementation of hook_perm().
 */
function recurring_globalcollect_perm() {
  return array('administer recurring_globalcollect');
}

/**
 * Callback for menu path "admin/settings/recurring_globalcollect".
 */
function recurring_globalcollect_settings() {
  $form = array();

  $defaultTestUrl = buildDefaultTestUrl();
  
  $form[ 'recurring_globalcollect' ][ 'globalcollect_url' ] = array(
    '#maxlength' => 255,
    '#type' => 'textfield',
    '#title' => t('Global Collect Url'),
    '#required' => FALSE,
    '#default_value' => variable_get('globalcollect_url', $defaultTestUrl),
    '#description' => t( 'The url to the Global Collect Gateway.' ),
  );

  $form[ 'recurring_globalcollect' ][ 'localhost_test_url' ] = array(
    '#maxlength' => 255,
    '#type' => 'textfield',
    '#title' => t('Default Testing Url'),
    '#required' => FALSE,
    '#default_value' => variable_get('localhost_test_url', $defaultTestUrl),
    '#description' => t( 'The url to the local server to test the connection. This should point to your CiviCRM host.' ),
  );
  
  // Get the path of the file to make sure it is installed.
  $standalone_globalcollect_adapter_path = variable_get('standalone_globalcollect_adapter_path', null);

  // Flag to tell the user to install the library
  $standalone_globalcollect_adapter_installed = is_dir( $standalone_globalcollect_adapter_path ) ? '<span style="color:green;">Installed</span>' : '<span style="color:red;">Please install</span>';

  $form['standalone_globalcollect_adapter_path'] = array(
    '#type' => 'textfield',
    '#title' => t('StandaloneGlobalCollectAdapter Path'),
    '#required' => TRUE,
    '#default_value' => $standalone_globalcollect_adapter_path,
    '#description' => t($standalone_globalcollect_adapter_installed . ' Link: ') . l(t('Current version of payment_library'), "https://svn.wikimedia.org/viewvc/wikimedia/trunk/fundraising-misc/payment_library/"),
  );

  $form['recurring_globalcollect_merchant_id'] = array(
    '#type' => 'textfield',
    '#title' => t('Global Collect Merchant ID'),
    '#required' => FALSE,
    '#default_value' => variable_get('recurring_globalcollect_merchant_id', 0),
  );

  $form['recurring_globalcollect_failure_retry_rate'] = array(
    '#type' => 'textfield',
    '#title' => t('Failure retry rate'),
    '#required' => TRUE,
    '#default_value' => variable_get('recurring_globalcollect_failure_retry_rate', 1),
    '#description' => t('Enter the number of days to wait until retrying.'),
  );

  $form['recurring_globalcollect_failures_before_cancellation'] = array(
    '#type' => 'textfield',
    '#title' => t('Failures before subscription is cancelled'),
    '#required' => TRUE,
    '#default_value' => variable_get('recurring_globalcollect_failures_before_cancellation', 3),
    '#description' => t('Enter the number of attempts to wait until the subscription is cancelled..'),
  );

  $form['recurring_globalcollect_run_missed_days'] = array(
    '#type' => 'textfield',
    '#title' => t('Catch up missed days'),
    '#required' => TRUE,
    '#default_value' => variable_get('recurring_globalcollect_run_missed_days', 3),
    '#description' => t('Enter the number of days in the past to start batching payments that were missed in the past X days.'),
  );

  $form['recurring_globalcollect_batch_max'] = array(
    '#type' => 'textfield',
    '#title' => t('Maximum number of payments to batch'),
    '#required' => TRUE,
    '#default_value' => variable_get('recurring_globalcollect_batch_max', 100),
    '#description' => t('The maximum batch size cannot be overridden from drush.'),
  );

  $form['recurring_globalcollect_batch'] = array(
    '#type' => 'select',
    '#title' => t('Number of payments to process in the cron job. If set to 0, the cron job will do nothing.'),
    '#required' => TRUE,
    '#default_value' => variable_get('recurring_globalcollect_batch', 0),
    '#description' => t('This may be overridden with: `drush rg --batch=10`'),
    '#options' => array(
      0 => 0,
      1 => 1,
      5 => 5,
      10 => 10,
      20 => 20,
      30 => 30,
      40 => 40,
      50 => 50,
      75 => 75,
      100 => 100,
    ),
  );
  
  return system_settings_form($form);
}

/**
 * recurring_globalcollect_batch_process
 *
 * This is the entry function for this module.
 *
 * This function is invoked here: drush_recurring_globalcollect() 
 * @see drush_recurring_globalcollect() 
 *
 * Validation is performed here: drush_recurring_globalcollect_validate()
 * @see drush_recurring_globalcollect_validate()
 *
 * @param array $options 
 * - $options['batch'] The number of contributions to process. If empty or not set or zero, no contributions will be processed.
 * - $options['date'] @uses strtotime()
 * - $options['url'] Used for testing and overriding the url
 */
function recurring_globalcollect_batch_process($options = array()) {

  // The number of contributions to process
  $batch = (integer) variable_get('recurring_globalcollect_batch', 0);
  
  watchdog('recurring_globalcollect', 'Attempting to process up to ' . $batch . ' recurring contribution(s).');

  $contribution_batch = wmf_civicrm_get_next_sched_contribution($batch);
  if ($contribution_batch)
  {
      $result = recurring_globalcollect_process($contribution_batch, $options);
  }

  $processed = count($result['succeeded']) + count($result['failed']);
  if ($processed > 0) {
    $message = "Processed $processed contribution(s).";
    if (!empty($result['failed']))
        $message .= " Encountered ".count($result['failed'])." failures.";
    watchdog('recurring_globalcollect', $message);
  }
  else {
    watchdog('recurring_globalcollect', 'No contributions processed.');
  }
}

/**
 * Remove one item from the queue and process it.
 *
 * @param  array  $options
 *
 * $options:
 * - string  $date The date to process.
 *
 * You are not allowed to process future dates. This generates an error
 *
 * $options['date'] @uses strtotime()
 *
 * The default date to process is today.
 *
 * The default process is next_sched_contribution.
 *
 * If you pick an incorrect process, an error will be generated.
 *
 * @uses recurring_globalcollect_process_error()
 * @uses recurring_globalcollect_process_validate_options()
 *
 * @return  boolean  Returns false on error. Returns true if contributions were processed. Returns false if no contributions are ready to be processed.
 */
function recurring_globalcollect_process($contribution_batch, $options = array())
{
  $succeeded = array();
  $failed = array();
  foreach ($contribution_batch as $contribution_recur)
  {
      // TODO refactor this nested try-catch mess
      try {
          $status = FALSE;
          try {
              $status = recurring_globalcollect_charge($contribution_recur, $options);
          }
          catch (WmfPaymentAdapterException $e)
          {
              throw new RecurringGlobalcollectGatewayException('gateway error', $contribution_recur, $e);
          }

          if ($status)
              $succeeded[] = $contribution_recur;
          else
              $failed[] = $contribution_recur;
      }
      catch (RecurringGlobalcollectException $e)
      {
          recurring_globalcollect_error($e);
          $failed[] = $contribution_recur;
      }
      catch (Exception $e) {
          $message = 'Batch processing aborted';
          $e = new RecurringGlobalcollectException($message, $contribution_recur, $e);
          recurring_globalcollect_error($e);
          $failed[] = $contribution_recur;
      }
          /*
           * FR #560:
           * catch (RecurringGlobalcollectCiviInsertException $e)
           * {
           * TODO This should not mark the payment as a failure, as it has 
           * successfully gone through once already. Precautions should be taken to 
           * make sure the transaction is marked as such, so the donor is not 
           * overcharged.
           */
  }

  return array(
      'succeeded' => $succeeded,
      'failed' => $failed,
  );
}

/**
 * Connect to GlobalCollect and process recurring charge
 */
function recurring_globalcollect_charge($contribution_recur, $options = array()){
  if (is_object($contribution_recur)) {
    $contribution_recur = (array) $contribution_recur;
  }

  $adapterOptions = array();
  
  // Set the merchant ID
  global $wgGlobalCollectGatewayMerchantID;
  $wgGlobalCollectGatewayMerchantID = variable_get('recurring_globalcollect_merchant_id', 0);

  $IPADDRESS = isset($options['IPADDRESS']) ? $options['IPADDRESS'] : '';
  
  $IPADDRESS = (empty($IPADDRESS) && isset($_SERVER['SERVER_ADDR'])) ? $_SERVER['SERVER_ADDR'] : ''; 
  
  if (empty($IPADDRESS)) {
    $IPADDRESS = '127.0.0.1';
    $message = 'You must specify a valid IP address.';
    //throw new Exception($message);
  }
  
  // Parse ORDERID
  if ( preg_match('/RECURRING GLOBALCOLLECT (?P<ORDERID>\w+)/', $contribution_recur['trxn_id'], $matches) ) {
    
    $ORDERID = $matches['ORDERID'];
  }
  else {
    $message = t('ORDERID was not found in the trxn_id');
    throw new RecurringGlobalcollectInternalException($message, $contribution_recur);
  }
   
  // Increment the EFFORTID
  $values = array(
	  'amount' => $contribution_recur['amount'],
	  'effort_id' => $contribution_recur['processor_id'] + 1,
	  'order_id' => $ORDERID,
	  'server_ip' => $IPADDRESS,
	  'currency_code' => $contribution_recur['currency'],
	  'payment_product' => '',
  );

  // Set the URL for the adapter
  if (isset($options['url'])) {
    $adapterOptions['url'] = $options['url'];
  }
  else {
    $adapterOptions['url'] = variable_get('globalcollect_url', '');
  }

  // $values and $options are used for testing.
  global $wgGlobalCollectGatewayURL;
  $wgGlobalCollectGatewayURL = recurring_globalcollect_build_url($values, $adapterOptions['url']);

  $standalone_globalcollect_adapter_path = variable_get('standalone_globalcollect_adapter_path', null);
  require_once implode(DIRECTORY_SEPARATOR, array($standalone_globalcollect_adapter_path, 'globalcollect.adapter.php'));

  $instance = new GlobalCollectAdapter( $adapterOptions );

  watchdog('recurring_globalcollect', 'Processing recurring charge: <pre>' . print_r($contribution_recur, true) . '</pre>');

  $instance->load_request_data( $values );
  
  _recurring_globalcollect_update_record_in_progress($contribution_recur['id']);
  
  $result = $instance->do_transaction('Recurring_Charge');
  
  // If success, add a record to the contribution table and send a thank you email.
  if ($result['status'] && empty($result['errors'])) {
    
    $contact = array(
        'id' => $contribution_recur['contact_id'],
    );
    
    $msg = array();
    $msg['fee'] = 0.00;
    
    $msg['gateway'] = 'globalcollect';
    $msg['gross'] = $contribution_recur['amount'];
    $msg['net'] = $msg['gross'] - $msg['fee'];
    //$msg['contribution_id'] = $contribution_recur['contribution_id'];
    $msg['gateway_txn_id'] = $contribution_recur['trxn_id'];
    $msg['payment_method'] = 'cc';
    $msg['payment_submethod'] = '';
    $msg['date'] = time();
    $msg['original_currency'] = $contribution_recur['currency'];
    $msg['original_gross'] = $msg['gross'];

    $msg = wmf_civicrm_normalize_contribution_amounts($msg);
    /*
     * This array needs to be rekeyed to be consistent with:
     *
     * @see thank_you_queue2civicrm_import
     *
     * id -> contribution_id
     *
     * @var array $contribution
     */
    $contribution = wmf_civicrm_message_contribution_insert($msg, $contact, $contribution_recur['id'], $values['effort_id']);
    $contribution['contribution_id'] = $contribution['id'];
    unset( $contribution['id'] );
    
    if ( !$contribution ){
        throw new RecurringGlobalcollectCiviInsertException($message); // FIXME $message not set
    }

    // Send thank you email, other post-import things
    module_invoke_all( 'recurring_globalcollect', $contribution );
 
    _recurring_globalcollect_update_record_success($contribution_recur['id']);
  }
  else
  {
    _recurring_globalcollect_update_record_failure($contribution_recur['id']);
    throw new RecurringGlobalcollectGatewayException('recurring charge failed', $result);
  }
  
  return $result;
}

/**
 * recurring_globalcollect_build_url
 *
 *
 * @param type $options
 * @return string; 
 */
function recurring_globalcollect_build_url($values, $gateway_url) {
    
  $url = isset($gateway_url) ? $gateway_url : '';

  // Fix case where boolean values are strings
  if ( $url == 'true') {
      $url = true;
  }
  elseif ( $url == 'false') {
      $url = false;
  }
  
  //$url = false;
  $returnUrl = variable_get('globalcollect_url', '');

  if (is_bool($url)) {

    $returnUrl  = variable_get('localhost_test_url', '');
    $returnUrl .= (substr($returnUrl, -1) == '/') ? '' : '/';
    $returnUrl .= 'sites/all/modules/recurring_globalcollect/tests/resources/responses/';
    // Fail should go to a global collect example failure. A 404 will do for now.

    if ($url) {
      $returnUrl .=  'curlTransaction.valid.response.php?';
      $returnUrl .=  '&ORDERID=' . $values['order_id'];
      $returnUrl .=  '&EFFORTID=' . $values['effort_id'];
      $returnUrl .=  '&IPADDRESS=' . $values['server_ip'];
    }
    else {
      $returnUrl .= '404.php';
    }
  }
  elseif (is_numeric($url)) {

    $returnUrl  = variable_get('localhost_test_url', '');
    $returnUrl .= (substr($returnUrl, -1) == '/') ? '' : '/';
    $returnUrl .= 'sites/all/modules/recurring_globalcollect/tests/resources/responses/';

    $returnUrl .= $url . '.php';
  }
  elseif (!empty($url)) {

    if (substr($url, 0, 4) == 'http') {
      
      // Setting a full url
      $returnUrl = $url;
    }
    else {
      $returnUrl  = variable_get('localhost_test_url', '');
      $returnUrl .= $url;
    }
      
  }

  return $returnUrl;
}

/**
 * Create the form to search for subscriptions by order id.
 */ 
function recurring_globalcollect_search_by_order_id_form() {

  $form['submit'] = array(
    '#value' => 'Search by order id',
    '#type' => 'submit'
  );
  
  $form['order_id'] = array(
    '#type' => 'textfield',
    '#title' => 'Order id',
    '#default_value' => '',
    '#required' => TRUE
  );
  
  return $form;
}

/** 
 * Implementation of hook_form_submit
 *
 * Submits a form to search for subscriptions by order id.
 */
function recurring_globalcollect_search_by_order_id_form_submit($form, &$form_state) {
  
  $order_id = isset( $form_state['values']['order_id'] ) ? (integer) $form_state['values']['order_id'] : 0;
  
  $record = _recurring_globalcollect_get_subscription_by_order_id($order_id);
  
  if ( $record === false ) {
  
    $message = 'No results found.';
    
  } else {
    $display_name = isset( $record['display_name'] ) ? $record['display_name'] : 'Unknown donor';
    $trxn_id = isset( $record['trxn_id'] ) ? $record['trxn_id'] : '';
    $cid = isset( $record['contact_id'] ) ? $record['contact_id'] : '';
    
    // Create a link to the recurring contribution for the donor.
    $link = '<a href="?q=civicrm/contact/view&reset=1&selectedChild=contribute&cid=' . urlencode($cid) . '#Contributions">' . htmlspecialchars($display_name) . '</a>';
    $message = 'Found the contact [' . $link . '] for the order id [ ' . $order_id . ' ] and with the transaction id [ ' . htmlspecialchars($trxn_id) . ' ]';
  }
  
  drupal_set_message($message);
}
