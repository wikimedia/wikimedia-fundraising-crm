<?php

use SmashPig\Core\UtcDate;
use SmashPig\PaymentData\ReferenceData\CurrencyRates;

require_once 'recurring.inc';
require_once 'tracking.inc';

/**
 * Ensure the specified option value exists.
 *
 * @param string $group_name
 * @param string $value
 */
function wmf_civicrm_ensure_option_value_exists($group_name, $value) {
  $params = array(
    'option_group_id' => $group_name,
    'name' => $value,
    'label' => $value,
    'value' => $value,
    'is_active' => 1,
  );
  $existingValues = civicrm_api3('OptionValue', 'get', array(
    'option_group_id' => $params['option_group_id'],
    'name' => $params['name'],
    'sequential' => 1,
  ));
  $createRequired = FALSE;
  if ($existingValues['count'] == 0) {
    $createRequired = TRUE;
  }
  elseif (!$existingValues['values'][0]['is_active']) {
    $params['id'] = $existingValues['values'][0]['id'];
    $createRequired = TRUE;
  }
  if ($createRequired) {
    civicrm_api3('OptionValue', 'create', $params);
    // It won't take much to rebuild this & we don't know the entity.
    // This should be rare.
    wmf_civicrm_flush_cached_options();
  }
}

function civicrm_option_group_id( $group_name ) {
    $api = civicrm_api_classapi();
    $success = $api->OptionGroup->Get(array(
        'name' => $group_name,
    ));
    if ( $success && $api->values ) {
        return $api->values[0]->id;
    }
}

function civicrm_api_contribution_status($key = null)
{
    return wmf_civicrm_get_option('Contribution', 'contribution_status_id', $key);
}

function civicrm_api_classapi()
{
	civicrm_initialize();
	if (module_load_include('php', 'civicrm', '../api/class.api') === FALSE)
	{
		watchdog('civicrm_api', t('Failed to load civicrm api classes'), array(), WATCHDOG_ERROR);
	}
	else
	{
		return new civicrm_api3();
	}
}

/**
 * Determines the settlement currency for a given donation.
 * Argument is a queue message or a civicrm contribution array.
 * TODO: implement hook to determine our actual settlement currency.
 */
function wmf_civicrm_get_settlement_currency($transaction)
{
	return 'USD';
}

/**
 * Given the date a payment was settled (in unix seconds), recalculate the
 * amount in USD using the exchange rate at that moment.  Put this amount in a
 * custom field.
 * Then, set the civi amounts and currencies to reflect the real settlement
 * currency and amount.
 *
 * Return the contribution array with these extra fields merged in.
 */
function wmf_civicrm_settle( $contribution, $settled_timestamp = null )
{
    if ( $settled_timestamp === null ) {
        // Get the stored date
        // FIXME wmf_civicrm_get_custom_values('settlement_date');
        $field = wmf_civicrm_get_custom_field_name( 'settlement_date' );
        $params = array(
            'entityID' => $contribution['id'],
            $field => 1
        );
        $result = CRM_Core_BAO_CustomValueTable::getValues( $params );
        $settlement_db_date = $result[$field];
        $settled_timestamp = wmf_common_date_parse_string( $settlement_db_date );
        $settlement_db_date = wmf_common_date_unix_to_sql( $settled_timestamp );
    } else {
        $settlement_db_date = wmf_common_date_unix_to_sql( $settled_timestamp );
    }

    list($original_currency, $original_amount) = explode(" ", $contribution['source']);
    $total_usd = round(exchange_rate_convert($original_currency, $original_amount, $settled_timestamp), 2);

    $custom_values = array(
        'total_usd' => $total_usd,
        'settlement_date' => $settlement_db_date,
    );
    wmf_civicrm_set_custom_field_values($contribution['id'], $custom_values);

    $settled_currency = wmf_civicrm_get_settlement_currency( $contribution );
    if ( $contribution['currency'] != $settled_currency ) {
        $settlement_convert =
            exchange_rate_convert( $settled_currency, 1, $settled_timestamp );
        $contribution['total_amount'] = round( $contribution['total_amount'] * $settlement_convert, 2 );
        $contribution['fee_amount'] = round( $contribution['fee_amount'] * $settlement_convert, 2 );
        $contribution['net_amount'] = round( $contribution['net_amount'] * $settlement_convert, 2 );

        $contribution['currency'] = $settled_currency;

        $contribution['version'] = 3; //WTF

        $contribution_result = civicrm_api( "Contribution", "Create", $contribution );
        if ( array_key_exists( 'is_error', $contribution_result ) && $contribution_result['is_error'] != 0 ) {
            throw new WmfException( "IMPORT_CONTRIB", "Couldn't update contribution with new settlement info. Original error: {$contribution_result['error_message']}. txn_id: {$contribution['trxn_id']}" );
        }
    }

    return array_merge( $contribution, $custom_values );
}

function wmf_civicrm_get_custom_values( $entity_id, $names, $group_name = null )
{
    $names = (array)$names;
    $params[ 'entityID' ] = $entity_id;
    foreach ( $names as $name ) {
        $field = wmf_civicrm_get_custom_field_name( $name, $group_name );
#var_export( "Custom field mapping: {$name} -> {$field}" );
        $params[ $field ] = 1;
        $field_map[ $field ] = $name;
    }
    $result = CRM_Core_BAO_CustomValueTable::getValues( $params );
    $ret = array();
    foreach ( $result as $field => $value ) {
        if ( array_key_exists( $field, $field_map ) ) {
            $ret[ $field_map[ $field ] ] = $value;
        }
    }
    return $ret;
}

function wmf_civicrm_set_custom_field_values($entity_id, $map, $group_name = null)
{
    $params = array(
        'entityID' => $entity_id,
    );
    $custom_fields = wmf_civicrm_get_custom_field_map(array_keys($map), $group_name);
    foreach ($map as $field_name => $value)
    {
        $params[$custom_fields[$field_name]] = $value;
    }
    $result = CRM_Core_BAO_CustomValueTable::setValues($params);
    if (!empty($result['is_error']))
    {
        throw new WmfException( 'CIVI_CONFIG',
            t( 'Failed to set custom values: id !id, error: !err', array( '!id' => $entity_id, '!err' => $result['error_message'] ) )
        );
    }
}

function wmf_civicrm_get_custom_field_map( $field_names, $group_name = null )
{
    static $custom_fields = array();
    foreach ($field_names as $name)
    {
        if (empty($custom_fields[$name]))
        {
            $id = CRM_Core_BAO_CustomField::getCustomFieldID( $name, $group_name );
            $custom_fields[$name] = "custom_{$id}";
        }
    }

    return $custom_fields;
}

function wmf_civicrm_get_custom_field_name( $field_name, $group_name = null ) {
    $custom_fields = wmf_civicrm_get_custom_field_map( array( $field_name ), $group_name );
    return $custom_fields[ $field_name ];
}

/**
 * Try to import a transaction message into CiviCRM, otherwise
 * throw an exception.
 *
 * @param array $msg
 * @return array Contribution as inserted
 */
function wmf_civicrm_contribution_message_import( &$msg ) {
    civicrm_initialize();

    $msg = wmf_civicrm_verify_message_and_stage($msg);

    // Associate with existing recurring records
    if ( $msg['recurring']
        && !$msg['contribution_recur_id']
    ) {
        if ( $msg['subscr_id'] ) {
            $recur_record = wmf_civicrm_get_gateway_subscription( $msg['gateway'], $msg['subscr_id'] );
            if ( $recur_record ) {
                watchdog( 'queue2civicrm_import', 'Found matching recurring record for subscr_id: ' . $msg['subscr_id'], NULL, WATCHDOG_INFO );
                $msg['contribution_recur_id'] = $recur_record->id;
                $msg['contact_id'] = $recur_record->contact_id;
            }
        } else {
            throw new WmfException( 'INVALID_MESSAGE', 'Recurring donation, but no subscription ID found.' );
        }
    }

    if ( !$msg['contact_id'] ) {
      wmf_civicrm_message_create_contact($msg);
    }
    else {
      if (isset($msg['employer_id'])) {
        civicrm_api3('Contact', 'create', array('contact_id' => $msg['contact_id'],'employer_id' => $msg['employer_id']));
      }
      // We have set the bar for invoking a location update fairly high here - ie state,
      // city or postal_code is not enough, as historically this update has not occurred at
      // all & introducing it this conservatively feels like a safe strategy.
      if (!empty($msg['street_address'])) {
        wmf_civicrm_message_location_update($msg, array('id' => $msg['contact_id']));
      }
      elseif (!empty($msg['email'])) {
        // location_update updates email, if set and address, if set.
        // However, not quite ready to start dealing with the situation
        // where less of the address is incoming than already exists
        // hence only call this part if street_address is empty.
        wmf_civicrm_message_email_update($msg, $msg['contact_id']);
      }
    }

    // Make new recurring record if necessary
    $initial_recurring = ( $msg['recurring'] && !$msg['contribution_recur_id'] );
    if ( $initial_recurring ) {
        watchdog( 'queue2civicrm_import', 'Attempting to insert new recurring subscription: ' . $msg['subscr_id'], NULL, WATCHDOG_INFO );

        // FIXME: level across processors
        if ( $msg['gateway'] === 'globalcollect' ) {
            if ( false === strpos( $msg['subscr_id'], 'RECURRING GLOBALCOLLECT' ) ) {
                $msg['subscr_id'] = "RECURRING GLOBALCOLLECT {$msg['subscr_id']}";
            }
        }

        wmf_civicrm_message_contribution_recur_insert( $msg, $msg['contact_id'], $msg['subscr_id'] );
        $recur_record = wmf_civicrm_get_gateway_subscription( $msg['gateway'], $msg['subscr_id'] );
        $msg['contribution_recur_id'] = $recur_record->id;
    }

    // Look up soft credit contact.
    if ( !empty( $msg['soft_credit_to'] ) ) {

        $soft_credit_contact = civicrm_api3('Contact', 'Get', array(
            'organization_name' => $msg['soft_credit_to'],
            'sequential' => 1,
            'return' => 'id',
        ) );
        if ( $soft_credit_contact['count'] !== 1 ) {
            throw new WmfException(
                'INVALID_MESSAGE',
                "Bad soft credit target, [${msg['soft_credit_to']}]"
            );
        }
        # FIXME: awkward to have the two fields.
        $msg['soft_credit_to_id'] = $soft_credit_contact['id'];
    }

    // Insert the contribution record.
    $contribution = _wmf_civicrm_message_contribution_insert( $msg );

    if ( !$msg['recurring'] || $initial_recurring ) {
        // Map the tracking record to the CiviCRM contribution
        // @FIXME what do we do if this returns false?  nothing at the moment...
        wmf_civicrm_message_update_contribution_tracking( $msg, $contribution );
    }

    if ( !empty( $msg['notes'] ) ) {
        // TODO: Handle failure.
        civicrm_api3( "Note", "Create", array(
            'entity_table' => 'civicrm_contact',
            'entity_id' => $msg['contact_id'],
            'note' => $msg['notes'],
        ) );
    }

    return $contribution;
}

/**
 * Create a contact from the $msg array and set the contact_id.
 *
 * @param array $msg
 *   Normalised wmf msg array.
 *
 * @throws \WmfException
 */
function wmf_civicrm_message_create_contact(&$msg) {
  $contact = wmf_civicrm_message_contact_insert($msg);
  wmf_civicrm_message_location_insert($msg, $contact);
  $msg['contact_id'] = $contact['id'];
}

/**
 * Insert the contribution record.
 *
 * This is an internal method, you must be looking for
 * @see wmf_civicrm_contribution_message_import.
 *
 * @param array $msg
 *
 * @return array
 */
function _wmf_civicrm_message_contribution_insert( $msg )
{
    $transaction = WmfTransaction::from_message( $msg );
    $trxn_id = $transaction->get_unique_id();


    $contribution = array(
        'contact_id' => $msg['contact_id'],
        'total_amount' => $msg['gross'],
        // CiviCRM supports financial_type_id rather than contribution_type_id now. Handling both here
        // is a first step to deprecating contribution_type_id.
        'financial_type_id' => empty($msg['financial_type_id']) ? $msg['contribution_type_id'] : $msg['financial_type_id'],
        'payment_instrument_id' => $msg['payment_instrument_id'],
        'fee_amount' => $msg['fee'],
        'net_amount' => $msg['net'],
        'trxn_id' => $trxn_id,
        'receive_date' => wmf_common_date_unix_to_civicrm( $msg['date'] ),
        'currency' => $msg['currency'],
        'source' => $msg['original_currency'] . ' ' . $msg['original_gross'],
        'contribution_recur_id' => $msg['contribution_recur_id'],
        'check_number' => $msg['check_number'],
        'soft_credit_to' => $msg['soft_credit_to_id'],
        'debug' => TRUE,
    );

    // Add the thank you date when it exists and is not null (e.g.: we're importing from a check)
    if ( array_key_exists( 'thankyou_date', $msg ) && is_numeric( $msg[ 'thankyou_date' ] ) ) {
        $contribution[ 'thankyou_date' ] = wmf_common_date_unix_to_civicrm( $msg['thankyou_date'] );
    }

    // Store the identifier we generated on payments
    if ( !empty( $msg['order_id'] ) ) {
        $contribution['invoice_id'] = $msg['order_id'];
        // The invoice_id column has a unique constraint
        if ( $msg['recurring'] ) {
            $contribution['invoice_id'] .= '|recur-' . UtcDate::getUtcTimestamp();
        }
    }

    /**
    *  Hopefully the Civi API will eventually handle custom fields in the
    *  above "Create" call.
    *
    * NOTE: the custom field for "Gift_Information" indicates that check number is stored here.  It is not.
    */
    $custom_field_defaults = array(
        // Contribution_comments field does not appear to exist & is quietly ignored I believe.
        'Contribution_Comments' => '',
        'gateway_account' => '',
    );
    if ($contribution['total_amount'] >= 1000) {
        $custom_field_defaults['Campaign'] = 'Benefactor Gift';
    }

    // Legacy field names which do not match the message field names
    $custom_name_mangle = array(
        'comment' => 'Contribution_Comments',
        'direct_mail_appeal' => 'Appeal',
        'gift_source' => 'Campaign',
        'postmark_date' => 'Postmark_Date',
        'restrictions' => 'Fund',
        'stock_description' => 'Description_of_Stock',
        'gateway_status' => 'gateway_status_raw',
    );

    // Custom fields with names that match the message fields.
    $custom_name_passthrough = array(
        'gateway_account',
        'import_batch_number',
        'no_thank_you',
        'source_name',
        'source_type',
        'source_host',
        'source_run_id',
        'source_version',
        'source_enqueued_time',
    );

    $custom_fields = $custom_name_mangle
        + array_combine( $custom_name_passthrough, $custom_name_passthrough );

    $custom_vars = array();
    foreach ( $custom_fields as $msg_key => $custom_key ) {
        if ( array_key_exists( $msg_key, $msg ) ) {
            $custom_vars[$custom_key] = $msg[$msg_key];
        }
    }

    // Transform any unix timestamps into an unambiguous MySQL datetime literal.
    // If the date is already in mysql format, it will be 14 characters long:
    // YYYYmmddHHiiss :-/
    $date_mangle = array(
        'Postmark_Date',
        'source_enqueued_time',
    );
    foreach ( $date_mangle as $field ) {
        if ( array_key_exists( $field, $custom_vars )
            && is_numeric( $custom_vars[$field] )
            && strlen( $custom_vars[$field] ) < 14
        ) {
            $custom_vars[$field] = wmf_common_date_unix_to_sql( $custom_vars[$field] );
        }
    }

    $custom_vars += $custom_field_defaults;

    $custom_name_mapping = wmf_civicrm_get_custom_field_map( array_keys( $custom_vars ) );
    foreach ( $custom_name_mapping as $readable => $machined ) {
        if ( array_key_exists( $readable, $custom_vars ) ) {
            $contribution[$machined] = $custom_vars[$readable];
        }
    }

    watchdog( 'wmf_civicrm', 'Contribution array for civicrm_contribution_add(): ' . print_r($contribution, TRUE), NULL, WATCHDOG_DEBUG);
    try {
      $contribution_result = civicrm_api3("Contribution", "Create", $contribution);
      watchdog('wmf_civicrm', 'Contribution result from civicrm_contribution_add(): ' . print_r($contribution_result, TRUE), NULL, WATCHDOG_DEBUG);
    }
    catch (CiviCRM_API3_Exception $e) {
        watchdog( 'wmf_civicrm', 'Error inserting contribution: ' . $e->getMessage(), NULL, WATCHDOG_INFO );
        $duplicate = 0;

        try {
            if ( array_key_exists( 'invoice_id', $contribution ) ) {
                watchdog( 'wmf_civicrm', 'Checking for duplicate on invoice ID ' . $contribution['invoice_id'], NULL, WATCHDOG_INFO );
                $invoice_id = $contribution['invoice_id'];
                $duplicate = civicrm_api3( "Contribution", "getcount", array( "invoice_id" => $invoice_id ) );
            }
            if ( $duplicate > 0 ) {
                $contribution['invoice_id'] = $contribution['invoice_id'] . '|dup-' . UtcDate::getUtcTimeStamp();
                watchdog( 'wmf_civicrm', 'Found duplicate invoice ID, changing this one to ' . $contribution['invoice_id'], NULL, WATCHDOG_INFO );
                $contribution_result = civicrm_api3( "Contribution", "Create", $contribution );
                watchdog( 'wmf_civicrm', 'Contribution result from civicrm_contribution_add(): ' . print_r( $contribution_result, TRUE ), NULL, WATCHDOG_DEBUG );
                $msg['contribution_tags'][] = 'DuplicateInvoiceId';
            } else {
                throw new WmfException(
                    'INVALID_MESSAGE',
                    'Cannot create contribution, civi error!',
                    $e->getExtraParams()
                );
            }
        }
        catch ( CiviCRM_API3_Exception $eInner ) {
            throw new WmfException(
                'INVALID_MESSAGE',
                'Cannot create contribution, civi error!',
                $eInner->getExtraParams()
            );
        }
    }

    // Create any required tags on the contribution
    if ( $msg['contribution_tags'] ) {
        $supported_tags = array_flip( CRM_Core_BAO_Tag::getTags( 'civicrm_contribution' ) );
        $stacked_ex = array();
        foreach ( array_unique( $msg['contribution_tags'] ) as $tag ) {
            try {
                $tag_result = civicrm_api3( "EntityTag", "Create", array(
                    'entity_table' => 'civicrm_contribution',
                    'entity_id' => $contribution_result['id'],
                    'tag_id' => $supported_tags[$tag]
                ));
            } catch ( CiviCRM_API3_Exception $ex ) {
                $stacked_ex[] = "Failed to add tag {$tag} to contribution ID {$contribution_result['id']}. Error: " . $ex->getMessage();
            }
        }
        if ( !empty( $stacked_ex ) ) {
            throw new WmfException(
                "IMPORT_CONTRIB",
                implode( "\n", $stacked_ex )
            );
        }
    }

    return $contribution_result[ 'values' ][ $contribution_result[ 'id' ] ];
}

/**
 * Translate option value to CiviCRM id.
 *
 * Note that in general we do not need to translate these names to ids as the CiviCRM
 * api does that. This allows us to add additional error checking, although
 * possibly for not much gain.
 *
 * @param string $type
 * @param $name
 * @return bool
 */
function wmf_civicrm_get_civi_id($type, $name)
{
    static $civi_ids = array();
    $params = array('name' => $name);
    $dummy = array();

    if(array_key_exists($type, $civi_ids) && array_key_exists($name, $civi_ids[$type])) {
        return $civi_ids[$type][$name];
    }

    switch ($type) {
        case 'contribution_type_id':
        case 'financial_type_id':
            //fixme: This is probably the upside-down way to do it. Really ought to go through the API.
            //
            $result = CRM_Financial_BAO_FinancialType::retrieve($params, $dummy);
            if (!is_null($result)){
                $civi_ids[$type][$name] = $result->id;
                watchdog('wmf_civicrm', "Found id for contribution_type $name: " . $civi_ids[$type][$name]);
            } else {
                //make it. Or, throw an error here. Either way.
                //XXX nonono
                watchdog('wmf_civicrm', "Id for contribution_type $name not found. Creating...");
                $params['description'] = '';
                $params['accounting_code'] = strtoupper($name);
                $params['is_deductible'] = 1;
                $params['is_active'] = 1;
                $result = CRM_Financial_BAO_FinancialType::add($params, $dummy);
                $civi_ids[$type][$name] = $result->id;
                watchdog('wmf_civicrm', "New id for contribution_type $name :" . $civi_ids[$type][$name]);
            }
            $id = $civi_ids[$type][$name];
            if (empty($id)) {
                throw new WmfException( "CIVI_CONFIG",
                    t( 'Contribution Type "!name" not found!', array( '!name' => $name ) )
                );
            }
            return $id;
        case 'payment_instrument_id':
            $instruments = civicrm_api3('Contribution', 'getoptions', array('field' => 'payment_instrument_id'));
            return array_search($name, $instruments['values']);
            break;

        default:
            throw new WmfException("CIVI_CONFIG", t("Civi lookup for type '!type' not implemented", array("!type" => $type)));
    }
}

function wmf_civicrm_get_message_contribution_type( $msg ) {
	$gateway = strtolower( $msg['gateway'] );
    if ( $gateway === 'merkle' ) {
		return 'merkle';
	} elseif ( $gateway === 'arizonalockbox' ) {
        return 'Arizona Lockbox';
    } else {
		return 'cash';
	}
}

/**
 * Determines which civi-only payment instrument is appropriate for the current
 * message, and returns the civi payment instrument's human-readable display
 * string (if it exists).
 *
 * TODO lookup table
 *
 * @return string payment instrument label
 */
function wmf_civicrm_get_message_payment_instrument( $msg )
{
    civicrm_initialize();

    $payment_instrument = null;

    if ( isset( $msg['raw_payment_instrument'] ) ) {
        return $msg['raw_payment_instrument'];
    }

    if ( array_key_exists( 'payment_method', $msg ) && trim( $msg['payment_method'] ) != '' ){

        switch( strtolower( $msg[ 'payment_method' ] ) ){
            case 'check':
                $payment_instrument = 'Check';
                break;
            case 'bt':
                $payment_instrument = 'Bank Transfer';
                break;
            case 'cc':
                $payment_instrument = 'Credit Card';
                if ( empty( $msg['payment_submethod'] ) ) {
                    watchdog( 'wmf_civicrm', 'No credit card submethod given', NULL, WATCHDOG_WARNING );
                    break;
                }
                switch ( strtolower( $msg['payment_submethod'] ) ){
                    case 'visa':
                        $payment_instrument .= ': Visa';
                        break;
                    case 'visa-beneficial':
                        $payment_instrument .= ': Visa Beneficial';
                        break;
                    case 'visa-electron':
                        $payment_instrument .= ': Visa Electron';
                        break;
                    case 'visa-debit':
                        $payment_instrument .= ': Visa Debit';
                        break;
                    case 'mc':
                        $payment_instrument .= ': MasterCard';
                        break;
                    case 'mc-debit':
                        $payment_instrument .= ': MasterCard Debit';
                        break;
                    case 'amex':
                        $payment_instrument .= ': American Express';
                        break;
                    case 'maestro':
                        $payment_instrument .= ': Maestro';
                        break;
                    case 'solo':
                        $payment_instrument .= ': Solo';
                        break;
                    case 'laser':
                        $payment_instrument .= ': Laser';
                        break;
                    case 'jcb':
                        $payment_instrument .= ': JCB';
                        break;
                    case 'discover':
                        $payment_instrument .= ': Discover';
                        break;
                    case 'cb':
                        $payment_instrument .= ': Carte Bleue';
                        break;
                    case 'cmr':
                        $payment_instrument .= ': CMR Falabella';
                        break;
                    case 'diners':
                        $payment_instrument .= ': Diners';
                        break;
                    case 'elo':
                        $payment_instrument .= ': Elo';
                        break;
                    case 'hiper':
                        $payment_instrument .= ': HiperCard';
                        break;
                    case 'magna':
                        $payment_instrument .= ': Magna';
                        break;
                    case 'mercadolivre':
                        $payment_instrument .= ': MercadoLivre';
                        break;
                    case 'presto':
                        $payment_instrument .= ': Presto';
                        break;
                    case 'cabal':
                        $payment_instrument .= ': Cabal';
                        break;
                    case 'naranja':
                        $payment_instrument .= ': Naranja';
                        break;
                    case 'shopping':
                        $payment_instrument .= ': Tarjeta Shopping';
                        break;
                    case 'nativa':
                        $payment_instrument .= ': Nativa';
                        break;
                    case 'cencosud':
                        $payment_instrument .= ': Cencosud';
                        break;
                    case 'argen':
                        $payment_instrument .= ': Argencard';
                        break;
                    case 'webpay':
                        $payment_instrument .= ': Webpay';
                        break;
                    case 'bij':
                        $payment_instrument .= ': Bijenkorf';
                        break;
                }
                break;
            case 'dd':
                $payment_instrument = 'Direct Debit';
                break;
            case 'eft':
                $payment_instrument = 'EFT';
                break;
            case 'ew':
                switch( strtolower( $msg['payment_submethod'] ) ){
                    case 'ew_paypal':
                        $payment_instrument = 'Paypal';
                        break;
                    case 'ew_webmoney':
                        $payment_instrument = 'Webmoney';
                        break;
                    case 'ew_moneybookers':
                        $payment_instrument = 'Moneybookers';
                        break;
                    case 'ew_cashu':
                        $payment_instrument = 'Cashu';
                        break;
                    case 'ew_yandex':
                        $payment_instrument = 'Yandex';
                        break;
                    case 'ew_alipay':
                        $payment_instrument = 'Alipay';
                        break;
                }
                break;
            case 'obt':
                if ( strtolower( $msg['payment_submethod'] === 'bpay' ) ){
                    $payment_instrument = 'Bpay';
                }
                break;
            case 'rtbt':
                switch( strtolower( $msg['payment_submethod'] ) ){
                    case 'rtbt_nordea_sweden':
                        $payment_instrument = 'Nordea';
                        break;
                    case 'rtbt_ideal':
                        $payment_instrument = 'iDeal';
                        break;
                    case 'rtbt_enets':
                        $payment_instrument = 'Enets';
                        break;
                    case 'rtbt_sofortuberweisung':
                        $payment_instrument = 'Sofort';
                        break;
                    case 'rtbt_eps':
                        $payment_instrument = 'EPS';
                        break;
                }
                break;
            case 'stock':
                $payment_instrument = 'Stock';
                break;
            case 'cash':
                $payment_instrument = 'Cash';
                if ( empty( $msg['payment_submethod'] ) ) {
                    watchdog( 'wmf_civicrm', 'No cash submethod given', NULL, WATCHDOG_WARNING );
                    break;
                }
                switch ( strtolower( $msg['payment_submethod'] ) ){
                    case 'cash_boleto':
                        $payment_instrument = 'Boleto';
                        break;
                    case 'cash_banamex':
                        $payment_instrument = 'Banamex';
                        break;
                    case 'cash_bancomer':
                        $payment_instrument = 'Bancomer';
                        break;
                    case 'cash_davivienda':
                        $payment_instrument = 'Davivienda';
                        break;
                    case 'cash_efecty':
                        $payment_instrument = 'Efecty';
                        break;
                    case 'cash_oxxo':
                        $payment_instrument = 'OXXO';
                        break;
                    case 'cash_pago_facil':
                        $payment_instrument = 'Pago Facil';
                        break;
                    case 'cash_provencia_pagos':
                        $payment_instrument = 'Provencia Pagos';
                        break;
                    case 'cash_red_pagos':
                        $payment_instrument = 'Red Pagos';
                        break;
                    case 'cash_rapipago':
                        $payment_instrument = 'Rapi Pago';
                        break;
                    case 'cash_santander':
                        $payment_instrument = 'Santander';
                        break;
                }
                break;
            case 'payflowpro':
                if ( strtolower( $msg['gateway'] ) === 'payflowpro' ){
                    $payment_instrument = 'Credit Card';
                }
                break;

          case 'trilogy':
                $payment_instrument = 'Trilogy';
                break;
        }

    }
    if ( !$payment_instrument
            and array_key_exists( 'gateway', $msg )
    ) {
        switch ( strtolower( $msg['gateway'] ) ) {
        case 'amazon':
            $payment_instrument = 'Amazon';
            if ( array_key_exists( 'payment_method', $msg ) and strtolower( $msg['payment_method'] ) !== 'amazon' ) {
                watchdog( 'wmf_civicrm', 'payment_method constraint violated: gateway Amazon, but method=@method ; gateway_txn_id=@id', array( '@method' => $msg['payment_method'], '@id' => $msg['gateway_txn_id'] ), WATCHDOG_DEBUG );
            }
            break;
        case 'paypal':
        case 'paypal_ec':
            // These PayPal flows are distinct gateway classes, but are
            // recorded together.  They might share an account, although the
            // configuration will have to be broken up across gateway globals.
            $payment_instrument = 'Paypal';
            // FIXME: Case is spelled "PayPal", but existing records must be
            // migrated when we do that.

            // Validate method if provided.
            if ( array_key_exists( 'payment_method', $msg ) and strtolower( $msg['payment_method'] ) !== 'paypal' ) {
                watchdog( 'wmf_civicrm', 'payment_method constraint violated: gateway Paypal, but method=@method ; gateway_txn_id=@id', array( '@method' => $msg['payment_method'], '@id' => $msg['gateway_txn_id'] ), WATCHDOG_DEBUG );
            }
            break;
        case 'square':
            $payment_instrument = 'Square Cash';
            if ( array_key_exists( 'payment_method', $msg ) and strtolower( $msg['payment_method'] ) !== 'square' ) {
                watchdog( 'wmf_civicrm', 'payment_method constraint violated: gateway Square, but method=@method ; gateway_txn_id=@id', array( '@method' => $msg['payment_method'], '@id' => $msg['gateway_txn_id'] ), WATCHDOG_DEBUG );
            }
            break;
        case 'trilogy':
            $payment_instrument = 'Trilogy';
            if ( array_key_exists( 'payment_method', $msg ) and strtolower( $msg['payment_method'] ) !== 'trilogy' ) {
                watchdog( 'wmf_civicrm', 'payment_method constraint violated: gateway Trilogy, but method=@method ; gateway_txn_id=@id', array( '@method' => $msg['payment_method'], '@id' => $msg['gateway_txn_id'] ), WATCHDOG_DEBUG );
            }
            break;
        }
    }

    //I was going to check to make sure the target gateway was a real thing, but: Hello, overhead. No.
    return $payment_instrument;
}

/**
 * Normalize contribution amounts
 *
 * Do exchange rate conversions and set appropriate fields for CiviCRM
 * based on information contained in the message.
 *
 * Upon exiting this function, the message is guaranteed to have these fields:
 *    currency - settlement currency
 *    original_currency - currency remitted by the donor
 *    gross - settled total amount
 *    original_gross - remitted amount in original currency
 *    fee - processor fees, when available
 *    net - gross less fees
 *
 * @param $msg
 * @return array
 */
function wmf_civicrm_normalize_contribution_amounts( $msg ) {
    $msg = wmf_civicrm_format_currency_fields($msg);

    // If there is anything fishy about the amount...
    if ( ( empty( $msg['gross'] ) or empty( $msg['currency'] ) )
        and ( empty( $msg['original_gross'] ) or empty( $msg['original_currency'] ) )
    ) {
        // just... don't
        watchdog( 'wmf_civicrm', 'Not freaking out about non-monetary message.',
            NULL, WATCHDOG_INFO );
        return $msg;
    }

    if ( empty( $msg['original_currency'] ) && empty( $msg['original_gross'] ) ) {
        $msg['original_currency'] = $msg['currency'];
        $msg['original_gross'] = $msg['gross'];
    }

    $validFee = array_key_exists( 'fee', $msg ) && is_numeric( $msg['fee'] );
    $validNet = array_key_exists( 'net', $msg ) && is_numeric( $msg['net'] );
    if ( !$validFee && !$validNet ) {
        $msg['fee'] = '0.00';
        $msg['net'] = $msg['gross'];
    } elseif ( $validNet && !$validFee ) {
        $msg['fee'] = $msg['gross'] - $msg['net'];
    } elseif ( $validFee && !$validNet ) {
        $msg['net'] = $msg['gross'] - $msg['fee'];
    }

    $settlement_currency = wmf_civicrm_get_settlement_currency($msg);
    if ( $msg['currency'] !== $settlement_currency ) {
        watchdog( 'wmf_civicrm', 'Converting to settlement currency: %old -> %new',
            array( '%old' => $msg['currency'], '%new' => $settlement_currency ),
            WATCHDOG_INFO );
        try {
            $settlement_convert = exchange_rate_convert($msg['original_currency'], 1, $msg['date']) / exchange_rate_convert($settlement_currency, 1, $msg['date']);
        }
        catch (ExchangeRatesException $ex) {
            throw new WmfException( 'INVALID_MESSAGE', "UNKNOWN_CURRENCY: '{$msg['original_currency']}': " . $ex->getMessage() );
        }

        // Do exchange rate conversion
        $msg['currency'] = $settlement_currency;
        $msg['fee'] = $msg['fee'] * $settlement_convert;
        $msg['gross'] = $msg['gross'] * $settlement_convert;
        $msg['net'] = $msg['net'] * $settlement_convert;
    }

    // TODO: Lookup by currency
    $significantDecimals = 2;
    $msg['fee'] = round( $msg['fee'], $significantDecimals );
    $msg['gross'] = round( $msg['gross'], $significantDecimals );
    $msg['net'] = round( $msg['net'], $significantDecimals );

    return $msg;
}

/**
 * Format currency fields in passed array.
 *
 * Currently we are just stripping out commas on the assumption they are a
 * thousand separator and unhelpful.
 *
 * @param array $values
 * @param array $currencyFields
 *
 * @return array
 */
function wmf_civicrm_format_currency_fields($values, $currencyFields = array('gross', 'fee', 'net')) {
  foreach ($currencyFields as $field) {
    if (isset($values[$field])) {
      $values[$field] = str_replace(',', '', $values[$field]);
    }
  }
  return $values;
}

function wmf_civicrm_verify_message_and_stage($msg)
{
    $msg = wmf_civicrm_normalize_msg( $msg );

    $required = array(
        'gross',
        'currency',
        'gateway',
        'gateway_txn_id',
    );

    $err = array();
    foreach ($required as $key){
        if ( empty( $msg[$key] ) ) {
            $err[] = "Required Field '$key' not found in message.";
        }
    }

    if (floatval($msg['net']) <= 0 || floatval($msg['gross']) <= 0)
    {
        $err[] = "Positive amount required.";
    }

    if (!empty($err)) {
        throw new WmfException( 'CIVI_REQ_FIELD', $err );
    }

    $max_lengths = array(
        'check_number' => 255,
        'city' => 64,
        'email' => 254,
        'first_name' => 64,
        'last_name' => 64,
        'middle_name' => 64,
        'organization_name' => 128,
        'postal_code' => 64,
        'street_address' => 96,
        'supplemental_address_1' => 96,
        'supplemental_address_2' => 96,
    );
    $truncate_tags = array(
        'postal_code' => 'AddressTruncated',
        'street_address' => 'AddressTruncated',
        'supplemental_address_1' => 'AddressTruncated',
        'supplemental_address_2' => 'AddressTruncated',
        'city' => 'AddressTruncated',
    );
    foreach ( $max_lengths as $key => $limit ) {
        if ( strlen( $msg[$key] ) > $limit ) {
            if ( array_key_exists( $key, $truncate_tags ) ) {
                watchdog(
                    'wmf_civicrm',
                    'Truncating key !key to !len chars. Original: "!val". Applying tag !tag',
                    array( '!key' => $key, '!len' => $limit, '!val' => $msg[$key], '!tag' => $truncate_tags[$key] ),
                    WATCHDOG_WARNING
                );
                $msg[$key] = substr( $msg[$key], 0, $limit );
                $msg['contact_tags'][] = $truncate_tags[$key];
            } else {
                throw new WmfException( 'INVALID_MESSAGE', "Field '{$key}' is too long." );
            }
        }
    }

    //Now check to make sure this isn't going to be a duplicate message for this gateway.
    wmf_civicrm_check_for_duplicates( $msg['gateway'], $msg['gateway_txn_id'] );

    return $msg;
}

/**
 * Throw an exception if a contribution already exists
 *
 * @param string $gateway
 * @param string $gateway_txn_id
 * @throws WmfException
 */
function wmf_civicrm_check_for_duplicates( $gateway, $gateway_txn_id ) {
    $txn = wmf_civicrm_get_contributions_from_gateway_id(
        $gateway, $gateway_txn_id
    );
    if ( $txn ) {
        throw new WmfException(
            'DUPLICATE_CONTRIBUTION',
            'Contribution already exists. Ignoring message.'
        );
    }
}

/**
 * Insert the contact record
 *
 * Serves as a standard way for message processors to handle contact
 * insertion.  By passing a contact id, a contact can be updated.
 *
 * @param array $msg
 * @param int $contact_id
 * @return array
 */
function wmf_civicrm_message_contact_insert( $msg, $contact_id=NULL ) {
    // Set defaults for optional fields in the message
    if ( !array_key_exists( 'contact_type', $msg ) ) {
        $msg['contact_type'] = "Individual";
    } elseif ( $msg['contact_type'] != "Individual" && $msg['contact_type'] != "Organization" ) {
        // looks like an unsupported type was sent, revert to default
        watchdog( 'wmf_civicrm', 'Non-supported contact_type received: %type', array( '%type' => print_r( $msg['contact_type'], true )), WATCHDOG_INFO );
        $msg['contact_type'] = "Individual";
    }

    if ( !array_key_exists( 'contact_source', $msg ) ) {
        $msg['contact_source'] = "online donation";
    }

    // Honor the opt-out checkbox, if present, else, set default
    if ( !array_key_exists( 'optout', $msg ) ) {
        $msg['optout'] = 0;
    }

    // Create the contact record
    $contact = array(
        'id' => $contact_id,
        'contact_type' => $msg['contact_type'],
        'contact_source' => $msg['contact_source'],
        'debug' => TRUE,
    );
    if (strtolower($msg['contact_type']) !== "organization") {
      foreach (array('first_name', 'last_name', 'middle_name') as $name) {
        if (isset($msg[$name])) {
          $contact[$name] = substr(trim($msg[$name]), 0, 64);
        }
      }
      // @todo this may not be needed as core may handle, but unsure how it handles over-long strings.
      $contact['sort_name'] = substr(trim($msg['last_name'] . ', ' . $msg['first_name'], ' ,'), 0, 128);
      $contact['display_name'] = substr($msg['first_name'] . ' ' . $msg['last_name'], 0, 128 );
    }
    if ( strtolower( $msg['contact_type'] ) == "organization" ){
        // @todo probably can remove handling for sort name and display name now.
        $contact['sort_name'] = $msg['organization_name'];
        $contact['display_name'] = $msg['organization_name'];
        $contact['organization_name'] = $msg['organization_name'];
    }
    elseif (!empty($msg['employer_id'])) {
      $contact['employer_id'] = $msg['employer_id'];
    }
    if ( !empty( $msg['name_prefix'] ) ) {
        $contact['prefix_id'] = $msg['name_prefix'];
        wmf_civicrm_ensure_option_exists($msg['name_prefix'], 'prefix_id', 'individual_prefix');
    }
    if ( !empty( $msg['name_suffix'] ) ) {
        $contact['suffix_id'] = $msg['name_suffix'];
        wmf_civicrm_ensure_option_exists($msg['name_suffix'], 'suffix_id', 'individual_suffix');
    }
    if ( empty($msg['language']) ) {
        // TODO: use LanguageTag to prevent truncation of >2 char lang codes
        // guess from contribution_tracking data
        $tracking = wmf_civicrm_get_contribution_tracking( $msg );
        if ( $tracking and !empty($tracking['language']) ) {
            if ( strpos( $tracking['language'], '-' ) ) {
                // If we are already tracking variant, use that
                list( $language, $variant ) = explode( '-', $tracking['language'] );
                $contact['preferred_language'] = $language . '_' . strtoupper( $variant );
            } else {
                $contact['preferred_language'] = $tracking['language'];
                if ( !empty($tracking['country']) ) {
                    $contact['preferred_language'] .= '_' . $tracking['country'];
                }
            }
        } else {
            // FIXME: wish we had the contact_id here :(
            watchdog( 'wmf_civicrm', 'Failed to guess donor\'s preferred language, falling back to some hideous default', NULL, WATCHDOG_INFO );
        }
    } else {
        $contact['preferred_language'] = strtolower(substr($msg['language'], 0, 2));
        if ( !empty( $msg['country'] ) ) {
            $contact['preferred_language'] .= '_' . strtoupper(substr($msg['country'], 0, 2));
        }
    }
    if (!empty($contact['preferred_language'])) {
        if (!wmf_civicrm_check_language_exists($contact['preferred_language'])) {
          $parts = explode('_', $contact['preferred_language']);
          if (wmf_civicrm_check_language_exists($parts[0])) {
            // in other words en_NO will be converted to en
            // rather than Norwegian English.
            $contact['preferred_language'] = $parts[0];
          }
          else {
            // otherwise let's create it rather than fail.
            // seems like the easiest way not to lose visibility, data or the plot.
            wmf_civicrm_ensure_language_exists($contact['preferred_language']);
          }
        }
    }

    // Copy some fields, if they exist
    $direct_fields = array(
        'do_not_email',
        'do_not_mail',
        'do_not_phone',
        'do_not_sms',
        'is_opt_out',
    );
    foreach ( $direct_fields as $field ) {
        if ( isset( $msg[$field] ) ) {
            $contact[$field] = $msg[$field];
        }
    }

    $custom_vars = array();
    $custom_field_mangle = array(
        'do_not_solicit' => 'do_not_solicit',
        'org_contact_name' => 'Name',
        'org_contact_title' => 'Title',
    );
    foreach ( $custom_field_mangle as $msgField => $customField ) {
        if ( isset( $msg[$msgField] ) ) {
            $custom_vars[$customField] = $msg[$msgField];
        }
    }

    $custom_name_mapping = wmf_civicrm_get_custom_field_map( array_keys( $custom_vars ) );
    foreach ( $custom_name_mapping as $readable => $machined ) {
        if ( array_key_exists( $readable, $custom_vars ) ) {
            $contact[$machined] = $custom_vars[$readable];
        }
    }

    // Attempt to insert the contact
    try {
        $contact_result = civicrm_api3( "Contact", "Create", $contact );
        if ( $contact_id == NULL ){
            watchdog( 'wmf_civicrm', 'Result for adding contact: %contact', array( '%contact' => print_r( $contact_result, true )), WATCHDOG_DEBUG );
        } else {
            watchdog( 'wmf_civicrm', 'Result for updating contact: %contact', array( '%contact' => print_r( $contact_result, true )), WATCHDOG_DEBUG );
        }
    } catch ( CiviCRM_API3_Exception $ex ) {
        throw new WmfException(
            "IMPORT_CONTACT",
            "Contact could not be added. Aborting import. Contact data was " . print_r($contact, true) . " Original error: " . $ex->getMessage()
            . " Details: " . print_r($ex->getExtraParams(), TRUE)
        );
    }
    $contact_id = $contact_result['id'];

    // Add phone number
    if ( isset( $msg['phone'] ) ) {
      try {
        $phone_result = civicrm_api3( 'Phone', 'Create', array(
          // XXX all the fields are nullable, should we set any others?
          'contact_id' => $contact_id,
          'location_type_id' => wmf_civicrm_get_default_location_type_id(),
          'phone' => $msg['phone'],
          'phone_type_id' => 'Phone',
          'is_primary' => 1,
          'debug' => TRUE,
        ));
      } catch ( CiviCRM_API3_Exception $ex ) {
        throw new WmfException(
          "IMPORT_CONTACT",
          "Failed to add phone for contact ID {$contact_id}: {$ex->getMessage()} " . print_r($ex->getExtraParams(), TRUE)
        );
      }
    }

    // Add groups to this contact.
    if (!empty($msg['contact_groups'])) {
        // TODO: Use CRM_Contact_GroupContact::buildOptions in Civi 4.4, also
        // in place of ::tag below.
        $supported_groups = array_flip( CRM_Core_PseudoConstant::allGroup() );
        $stacked_ex = array();
        foreach ( array_unique( $msg['contact_groups'] ) as $group ) {
            try {
                $tag_result = civicrm_api3( "GroupContact", "Create", array(
                    'contact_id' => $contact_id,
                    'group_id' => $supported_groups[$group],
                ));
            } catch ( CiviCRM_API3_Exception $ex ) {
                $stacked_ex[] = "Failed to add group {$group} to contact ID {$contact_id}. Error: " . $ex->getMessage();
            }
        }
        if ( !empty( $stacked_ex ) ) {
            throw new WmfException(
                "IMPORT_CONTACT",
                implode( "\n", $stacked_ex )
            );
        }
    }

    // Do we have any tags we need to add to this contact?
    if (!empty($msg['contact_tags'])) {
        $supported_tags = array_flip( CRM_Core_BAO_Tag::getTags( 'civicrm_contact' ) );
        $stacked_ex = array();
        foreach ( array_unique( $msg['contact_tags'] ) as $tag ) {
            try {
                $tag_result = civicrm_api3( "EntityTag", "Create", array(
                    'entity_table' => 'civicrm_contact',
                    'entity_id' => $contact_id,
                    'tag_id' => $supported_tags[$tag]
                ));
            } catch ( CiviCRM_API3_Exception $ex ) {
                $stacked_ex[] = "Failed to add tag {$tag} to contact ID {$contact_id}. Error: " . $ex->getMessage();
            }
        }
        if ( !empty( $stacked_ex ) ) {
            throw new WmfException(
                "IMPORT_CONTACT",
                implode( "\n", $stacked_ex )
            );
        }
    }

    // Create a relationship to an existing contact?
    if ( !empty( $msg['relationship_target_contact_id'] ) ) {
        $relationship_type = civicrm_api3( "RelationshipType", "Get", array(
            'name_a_b' => $msg['relationship_type'],
        ) );
        if ( !$relationship_type['count'] ) {
            throw new WmfException( 'IMPORT_CONTACT', "Bad relationship type: {$msg['relationship_type']}" );
        }

        try {
            civicrm_api3( "Relationship", "Create", array(
                'contact_id_a' => $contact_id,
                'contact_id_b' => $msg['relationship_target_contact_id'],
                'relationship_type_id' => $relationship_type['id'],
                'is_active' => 1,
            ) );
        } catch ( CiviCRM_API3_Exception $ex ) {
            throw new WmfException( 'IMPORT_CONTACT', $ex->getMessage() );
        }
    }

    return $contact_result;
}

/**
 * Ensure the selected language is valid in CiviCRM DB.
 *
 * In 4.6 CiviCRM validates preferred_language against the language
 * option_group in the DB.
 *
 * wmf has (at least in the tests) defined these ad hoc.
 * Options are to manage the list of available languages or create them at
 * run time if required. This function does the latter.
 *
 * When retrieved using getoptions it uses a pseudoconstant
 * so, the DB query won't run more than once. I haven't added an
 * extra level of caching into this function at this stage for fear of fragility
 * if it gets updated elsewhere but it could be done.
 *
 * @param string
 *
 * @return mixed
 * @throws \CiviCRM_API3_Exception
 */
function wmf_civicrm_ensure_language_exists($languageAbbreviation) {
    wmf_civicrm_ensure_option_exists($languageAbbreviation, 'preferred_language', 'languages', array('value' => substr($languageAbbreviation, 0, 2)));
}

/**
 * Check if the language string exists.
 *
 * @param string $languageAbbreviation
 *
 * @return bool
 */
function wmf_civicrm_check_language_exists($languageAbbreviation) {
  $languages = wmf_civicrm_get_valid_languages();
  return !empty($languages[$languageAbbreviation]);
}

/**
 * Get valid languages.
 *
 * @return array
 */
function wmf_civicrm_get_valid_languages() {
  static $languages;
  if (empty($languages)) {
    $available_options = civicrm_api3('Contact', 'getoptions', array(
      'field' => 'preferred_language',
    ));
    $languages = $available_options['values'];
  }
  return $languages;
}

/**
 * Ensure the required option value exists.
 *
 * @param string $option_value
 * @param string $field_name
 * @param string|int $option_group_name
 *   Option group name or option group ID if known
 * @param array $spec
 *   Values for the entity if it is to be created.
 * @param string $entity
 * @throws \CiviCRM_API3_Exception
 */
function wmf_civicrm_ensure_option_exists($option_value, $field_name, $option_group_name, $spec = array(), $entity = 'Contact') {
    $available_options = civicrm_api3($entity, 'getoptions', array(
        'field' => $field_name,
    ));
    if ($option_value && empty($available_options['values'][$option_value])) {
        civicrm_api3('OptionValue', 'create', array_merge(array(
            'option_group_id' => $option_group_name,
            'name' => $option_value,
        ), $spec));
    }
}

/**
 * Update the contact record
 *
 * Serves as a standard way for message processors to handle contact
 * updates.
 *
 * @param array $msg
 * @param int $contact_id
 * @return array
 */
function wmf_civicrm_message_contact_update( $msg, $contact_id )
{
    //FIXME: reverse the way these functions delegate.  Or eliminate -_insert.
    return wmf_civicrm_message_contact_insert( $msg, $contact_id );
}

/**
 * Insert the location record
 *
 * Serves as a standard way for message processors to handle location
 * insertion.
 *
 * @param array $msg
 * @param array $contact
 */
function wmf_civicrm_message_location_insert( $msg, $contact ) {
    wmf_civicrm_message_email_insert( $msg, $contact[ 'id' ] );
    wmf_civicrm_message_address_insert( $msg, $contact[ 'id' ] );
}

/**
 * Update the location record
 *
 * Serves as a standard way for message processors to handle location
 * updates.
 *
 * @param array $msg
 * @param array $contact
 */
function wmf_civicrm_message_location_update($msg, $contact) {
    wmf_civicrm_message_email_update($msg, $contact['id']);
    wmf_civicrm_message_address_update($msg, $contact['id']);
}

/**
 * Updates the email for a contact.
 *
 * @param string $msg
 * @param int $contact_id
 * @throws \WmfException
 */
function wmf_civicrm_message_email_update($msg, $contact_id ) {
  if (!wmf_civicrm_is_email_valid(CRM_Utils_Array::value('email', $msg))) {
    return;
  }

  try {
    $loc_type_id = isset($msg['email_location_type_id']) ? $msg['email_location_type_id'] : wmf_civicrm_get_default_location_type_id();
    $isPrimary = isset($msg['email_location_type_id']) ? 0 : 1;
    civicrm_api3( "Email", "Replace", array(
      'debug' => 1,
      'location_type_id' => $loc_type_id,
      'contact_id' => $contact_id,
      'values' => array(array(
        'email' => $msg[ 'email' ],
        'is_primary' => $isPrimary,
        'is_billing' => $isPrimary,
      ),
    )));
  }
  catch (CiviCRM_API3_Exception $e) {
    throw new WmfException( 'IMPORT_CONTACT', "Couldn't store email for the contact.", $e->getExtraParams());
  }
}

/**
 * We do not store empty emails or placeholder emails.
 *
 * @param string $email
 * @return bool
 */
function wmf_civicrm_is_email_valid($email) {
  if(empty($email) || $email === 'nobody@wikimedia.org' ){
    return FALSE;
  }
  return TRUE;
}

/**
 * Updates the email for a contact.
 *
 * If updating or unsure use the marginally slower update function.
 *
 * @param string $msg
 * @param int $contact_id
 * @throws \WmfException
 */
function wmf_civicrm_message_email_insert($msg, $contact_id ) {
    if (!wmf_civicrm_is_email_valid(CRM_Utils_Array::value('email', $msg))) {
        return;
    }

    $loc_type_id = wmf_civicrm_get_default_location_type_id();

    $email_params = array(
        'contact_id' => $contact_id,
        'email' => $msg[ 'email' ],
        'is_primary' => 1,
        'is_billing' => 1,
        'location_type_id' => $loc_type_id,
        'debug' => 1,
    );

    try {
      civicrm_api3("Email", "Create", $email_params);
    }
    catch (CiviCRM_API3_Exception $e) {
        throw new WmfException( 'IMPORT_CONTACT', "Couldn't store email for the contact.", $e->getExtraParams());
    }
}

/**
 * We do not store empty emails or placeholder emails.
 *
 * @param array $address
 * @return bool
 */
function wmf_civicrm_is_address_valid($address) {
  $meaningfulFields = array(
    'street_address',
    'supplemental_address_1',
    'city',
    'postal_code',
    'country_id',
    'state_province_id',
  );
  foreach ($meaningfulFields as $field) {
    if (!empty($address[$field])) {
      // We could also filter for strings like 'None' here
      // I feel like there is one like 'None provided' that is common.
      // only 241 instances of 'none' in street address and second place in the
      // none-stakes has only 15 instances of 'None of your business'
      // 'None of your goddamn business' got no traction with only one instance.
      return TRUE;
    }
  }
  return FALSE;
}

/**
 * Update address for a contact.
 *
 * @param array $msg
 * @param int $contact_id
 *
 * @throws \WmfException
 */
function wmf_civicrm_message_address_update($msg, $contact_id ) {

  // CiviCRM does a DB lookup instead of checking the pseudoconstant.
  // @todo fix Civi to use the pseudoconstant.
  $country_id = wmf_civicrm_get_country_id( $msg[ 'country' ] );
  $address = array(
    'is_primary' => 1,
    'street_address' => $msg['street_address'],
    'supplemental_address_1' => !empty($msg['supplemental_address_1']) ? $msg['supplemental_address_1'] : '',
    'city' => $msg['city'],
    'postal_code' => $msg['postal_code'],
    'country_id' => $country_id,
    'country' => $msg['country' ],
    'is_billing' => 1,
    'debug' => 1,
  );
  if (!empty($msg['state_province'])) {
    $address['state_province'] = $msg['state_province'];
    $address['state_province_id'] = wmf_civicrm_get_state_id($country_id, $msg['state_province']);
  }
  if (!wmf_civicrm_is_address_valid($address)) {
    return;
  }

  $address_params = array(
    'contact_id' => $contact_id,
    'location_type_id' => wmf_civicrm_get_default_location_type_id(),
    'values' => array($address),
  );

  try {
    civicrm_api3('Address', 'replace', $address_params);
  }
  catch (CiviCRM_API3_Exception $e) {
    throw new WmfException( 'IMPORT_CONTACT', "Couldn't store address for the contact.", $e->getExtraParams());
  }
}

/**
 * Insert a new address for a contact.
 *
 * If updating or unsure use the marginally slower update function.
 *
 * @param array $msg
 * @param int $contact_id
 *
 * @throws \WmfException
 */
function wmf_civicrm_message_address_insert($msg, $contact_id ) {
    $loc_type_id = wmf_civicrm_get_default_location_type_id();

    // We can do these lookups a bit more efficiently than Civi
    $country_id = wmf_civicrm_get_country_id( $msg[ 'country' ] );

    $address_params = array(
        'contact_id' => $contact_id,
        'location_type_id' => $loc_type_id,
        'is_primary' => 1,
        'street_address' => $msg['street_address'],
        'supplemental_address_1' => !empty($msg['supplemental_address_1']) ? $msg['supplemental_address_1'] : NULL,
        'city' => $msg['city'],
        'postal_code' => $msg['postal_code'],
        'country_id' => $country_id,
        'country' => $msg[ 'country' ],
        'is_billing' => 1,
        'version' => 3,
    );

    if ( !empty( $msg['state_province'] ) ) {
        $address_params['state_province'] = $msg['state_province'];
        $address_params['state_province_id'] = wmf_civicrm_get_state_id( $country_id, $msg['state_province'] );
    }

    if (!wmf_civicrm_is_address_valid($address_params)) {
        return;
    }
    // FIXME: api does not offer control over fixAddress flag
    // UPDATE - the fixAddress function mostly backs out early based on params
    // checks so as long as things like 'country_id' are set it doesn't seem very
    // expensive (& those checks would be an easy fix). Bypassing the api
    // probably does not gain us much.
    //$result = civicrm_api( "Address", "Create", $address_params );
    //if ( array_key_exists( 'is_error', $result ) && $result['is_error'] != 0 ) {

    $result = CRM_Core_BAO_Address::add( $address_params, false );
    if ( !$result ) {
        throw new WmfException( 'IMPORT_CONTACT', "Couldn't store address for the contact.");
    }
}

function wmf_civicrm_get_default_location_type_id() {
    $default_location_type = CRM_Core_BAO_LocationType::getDefault();
    return $default_location_type->id;
}

function wmf_civicrm_get_country_id( $raw ) {
	// ISO code, or outside chance this could be a lang_COUNTRY pair
	if ( preg_match( '/^([a-z]+_)?([A-Z]{2})$/', $raw, $matches ) ) {
		$code = $matches[2];

		$iso_cache = CRM_Core_PseudoConstant::countryIsoCode();
		$id = array_search( strtoupper( $code ), $iso_cache );
		if ( $id !== FALSE ) {
			return $id;
		}
	} else {
		$country_cache = CRM_Core_PseudoConstant::country( false, false );
		$id = array_search( $raw, $country_cache );
		if ( $id !== false ) {
			return $id;
		}
	}

	watchdog( 'wmf_civicrm',
		"Cannot find country: [%txt]",
		array( '%txt' => $raw ),
		WATCHDOG_NOTICE
	);
	return false;
}

/**
 * Find correct state for insertion
 *
 * When passing CiviCRM a state abbreviation, odd things can happen - like getting the right abbreviation, but the wrong state
 * So we'll pull back the correct state/province name based off of a user's country/state abbreviation
 */
function wmf_civicrm_get_state( $country, $state )
{
    if ( strlen( $country ) == 2 ) {
        $query = "SELECT s.name AS state_name FROM civicrm_country c, civicrm_state_province s WHERE s.country_id=c.id AND c.iso_code = :country AND s.abbreviation = :state";
    } else {
        $query = "SELECT s.name AS state_name FROM civicrm_country c, civicrm_state_province s WHERE s.country_id=c.id AND c.name = :country AND s.abbreviation = :state";
    }
    $dbs = wmf_civicrm_get_dbs();
    $dbs->push( 'civicrm' );
    $result = db_query( $query, array( ':country' => $country, ':state' => $state ) );
    if ( $result->rowCount() === 1 ){
        $state = $result->fetch()->state_name;
    }

    return $state;
}

function wmf_civicrm_get_state_id( $country_id, $state )
{
    $query = <<<EOS
SELECT id
FROM civicrm_state_province s
WHERE
    s.country_id = :country_id
    AND ( s.abbreviation = :state OR s.name = :state )
EOS;
    $dbs = wmf_civicrm_get_dbs();
    $dbs->push( 'civicrm' );
    $result = db_query( $query, array( ':country_id' => $country_id, ':state' => $state ) );
    if ( $result->rowCount() === 1 ){
        return $result->fetch()->id;
    }
    watchdog( 'wmf_civicrm',
        "Cannot find state: [%state] (country %country)",
        array( '%state' => $state, '%country' => $country_id ),
        WATCHDOG_NOTICE
    );
}



/**
 * Normalize the queued message
 *
 * Decodes the message and updates some of the message fields in ways
 * that are consistent with how we need to insert data into CiviCRM.
 * This should be useful by other modules processing contribution messages
 * out of the queue.
 *
 * TODO: Split this into a transformation chain.
 *
 * @param mixed $msg
 * @return array
 */
function wmf_civicrm_normalize_msg( $msg ) {
    // Decode the message body.
    if ( !is_array( $msg ) ) {
        $msg = json_decode( $msg->body, true );
    }

	$trim_strings = function( $input ) {
		if ( !is_string( $input ) ) {
			return $input;
		}
		return trim( $input );
	};

	$msg = array_map( $trim_strings, $msg );

    //defaults: Keys that aren't actually required, but which will cause some portion of the code to complain
    //if they don't exist (even if they're blank).
    // FIXME: don't use defaults.  Access msg properties using a functional interface.
    $defaults = array(
        // FIXME: Default to now. If you can think of a better thing to do in
        // the name of historical exchange rates.  Searching ts and
        // source_enqueued_time is a good start.
        'date' => time(),
        'first_name' => '',
        'middle_name' => '',
        'last_name' => '',
        'organization_name' => '',
        'email' => '',
        'street_address' => '',
        'supplemental_address_1' => '',
        'supplemental_address_2' => '',
        'city' => '',
        'country' => '',
        'state_province' => '',
        'postal_code' => '',
        'postmark_date' => null,
        'check_number' => null,
        'thankyou_date' => null,
        'recurring' => null,
        'utm_campaign' => null,
        'contact_id' => null,
        'contribution_recur_id' => null,
        'effort_id' => null,
        'subscr_id' => null,
        'contact_groups' => array(),
        'contact_tags' => array(),
        'contribution_tags' => array(),
        'soft_credit_to' => null,
        'soft_credit_to_id' => null,
    );
    $msg = $msg + $defaults;

    wmf_civicrm_removeKnownBadStringsFromAddressFields($msg);

    if ( empty( $msg['contribution_type_id'] ) ) {
        if ( empty( $msg['contribution_type'] ) ) {
            $msg['contribution_type'] = wmf_civicrm_get_message_contribution_type( $msg );

            if ( !$msg['contribution_type'] ) {
                throw new WmfException( 'INVALID_MESSAGE', 'No contribution type specified' );
            }
        }
        $msg['contribution_type_id'] = wmf_civicrm_get_civi_id( 'contribution_type_id', $msg['contribution_type'] );
    }

    if ( empty( $msg['payment_instrument_id'] ) ) {
        if ( empty( $msg['payment_instrument'] ) ) {
            $msg['payment_instrument'] = wmf_civicrm_get_message_payment_instrument( $msg );

            if ( !$msg['payment_instrument'] ) {
                throw new WmfException( 'INVALID_MESSAGE', 'No payment instrument specified' );
            }
        }
        // CiviCRM does not require us to do this translation. It will do the same thing
        // if we don't & through a mandatory_missing error.
        $msg['payment_instrument_id'] = wmf_civicrm_get_civi_id( 'payment_instrument_id', $msg['payment_instrument'] );
    }
    if ( !$msg['payment_instrument_id'] ) {
        throw new WmfException( "INVALID_MESSAGE", "No payment type found for message." );
    }

    // Convert times to Unix timestamps.
    if ( !is_numeric( $msg['date'] ) ) {
        $msg['date'] = wmf_common_date_parse_string($msg['date']);
    }
    // if all else fails, fall back to now.
    if ( empty( $msg['date'] ) ) {
        $msg['date'] = time();
    }

    // if we're missing a contrib id, insert new record to the table
    // this can happen if a user somehow makes a trxn from outside the normal workflow
    // Historically checks have been  ignored as they are completely offline.
    // T146295 has raised some questions about this.
    // code change respects previous recognition of 'payment_method' as being a little bit magic,
    // but also assumes that if you are setting utm_medium or utm_source in your import you intend them to be recorded.
    if ( !isset( $msg[ 'contribution_tracking_id' ] ) ) {
        if (
          (!empty($msg['utm_medium']) || !empty($msg['utm_source']))
          || (array_key_exists('payment_method', $msg) && strtoupper($msg['payment_method']) != "CHECK")
        ) {

            watchdog( 'wmf_civicrm', 'Contribution missing contribution_tracking_id', array(), WATCHDOG_DEBUG );
            //@fixme: For the regular transactions, this has been moved to the staging function. This needs to happen in recurring also, and then it can be removed here.
            $anonymous = ( array_key_exists( 'anonymous', $msg) && $msg['anonymous'] == true && strtoupper( $msg['anonymous'] ) != "FALSE" ) ? 1 : 0;
            $optout = ( array_key_exists( 'optout', $msg ) && $msg['optout'] == true && strtoupper( $msg['optout'] ) != "FALSE" ) ? 1 : 0;

            $source = isset($msg['utm_source']) ? $msg['utm_source'] : '..' . $msg['payment_method'];
            $medium = isset($msg['utm_medium']) ? $msg['utm_medium'] : 'civicrm';
            $campaign = isset($msg['utm_campaign']) ? $msg['utm_campaign'] : null;

            $tracking = array(
                'utm_source' => $source,
                'utm_medium' => $medium,
                'utm_campaign' => $campaign,
                'optout' => $optout,
                'anonymous' => $anonymous,
                'ts' => wmf_common_date_unix_to_sql( $msg['date'] )
            );
            if (
                !empty( $msg['country'] ) &&
				array_search( $msg['country'], CRM_Core_PseudoConstant::countryIsoCode() ) !== false
            ) {
                $tracking['country'] = $msg['country'];
            }
            $contribution_tracking_id = wmf_civicrm_insert_contribution_tracking( $tracking );
            watchdog( 'wmf_civicrm', 'Newly inserted contribution tracking id: @id', array( '@id' => $contribution_tracking_id ), WATCHDOG_DEBUG );
            $msg['contribution_tracking_id'] = $contribution_tracking_id;
        }
    }

    if ( $msg['recurring'] and !isset( $msg['start_date'] ) ) {
        $msg['start_date'] = $msg['date'];
        $msg['create_date'] = $msg['date'];
    }

    if ( $msg['recurring'] and !$msg['subscr_id'] ) {
        if ( $msg['gateway'] == 'globalcollect' ) {
            // Well randomly grab an ID, of course :-/
            $msg['subscr_id'] = $msg['gateway_txn_id'];
        } else if ( $msg['gateway'] == 'amazon' ) {
            // Amazon 'subscription id' is the Billing Agreement ID, which
            // is a substring of the Capture ID we record as 'gateway_txn_id'
            $msg['subscr_id'] = substr( $msg['gateway_txn_id'], 0, 19 );
        }
    }

    if ( !empty( $msg['thankyou_date'] ) ) {
        if ( !is_numeric( $msg['thankyou_date'] ) ) {
            $unix_time = wmf_common_date_parse_string( $msg['thankyou_date'] );
            if ( $unix_time !== false ) {
                $msg['thankyou_date'] = $unix_time;
            } else {
                watchdog( 'wmf_civicrm', 'Could not parse thankyou date: @date from @id', array( '@date' => $msg['thankyou_date'], '@id' => $msg['contribution_tracking_id'] ), WATCHDOG_DEBUG );
                unset( $msg['thankyou_date'] );
            }
        }
    }

    if ( empty( $msg['first_name'] ) and empty( $msg['last_name'] ) ) {
        $msg['first_name'] = 'Anonymous';
        $msg['last_name'] = '';
    }

    // Check for special flags
    // TODO: push non-generic cases into database
    if ( !empty( $msg['utm_campaign'] ) ) {
        switch ( $msg['utm_campaign'] ) {
        case 'NY2013':
            $msg['direct_mail_appeal'] = "New York Event 2013";
            break;
        case 'NYCShaku2013':
            $msg['direct_mail_appeal'] = "Shaku - NYC Event 2013";
            break;
        case 'SF2013':
            $msg['direct_mail_appeal'] = "San Francisco Event 2013";
            break;
        case 'Mossman':
            $msg['direct_mail_appeal'] = "Sheila Mossman";
            break;
        case 'Mediander':
            $msg['direct_mail_appeal'] = "Mediander";
            break;
        default:
            $directMailOptions = wmf_civicrm_get_options('Contribution', wmf_civicrm_get_custom_field_name('Appeal'));
            if ( !array_key_exists( $msg['utm_campaign'], $directMailOptions) ) {
              wmf_civicrm_ensure_option_value_exists(wmf_civicrm_get_direct_mail_field_option_name(), $msg['utm_campaign']);
            }
            $msg['direct_mail_appeal'] = $msg['utm_campaign'];
            break;
        }
    }

    $msg['anonymous'] = ((!empty( $msg['anonymous'] ) && strtoupper($msg['anonymous'] ) !== "FALSE") ? 1 : 0);
    $msg['optout'] = ((empty( $msg['optout'] ) || $msg['optout'] === 0 || $msg['optout'] === '0' || strtoupper( $msg['optout'] ) === "FALSE") ? 0 : 1);

    $list_fields = array(
        'contact_groups',
        'contact_tags',
        'contribution_tags',
    );
    foreach ( $list_fields as $field ) {
        if ( is_string( $msg[$field] ) ) {
            $msg[$field] = preg_split( '/[\s,]+/', $msg[$field], null, PREG_SPLIT_NO_EMPTY );
        }
        $msg[$field] = array_unique( $msg[$field] );
    }

    // set the correct amount fields/data and do exchange rate conversions.
    $msg = wmf_civicrm_normalize_contribution_amounts( $msg );

    watchdog( 'wmf_civicrm', 'Contribution (normalized):<pre>' . check_plain(print_r($msg, TRUE)) . '</pre>', NULL, WATCHDOG_INFO );

    return $msg;
}

/**
 * Remove known bad strings from address.
 *
 * This function focuses on specific forms of bad data with high
 * prevalence in the fields we see them in.
 *
 * @param array $msg
 */
function wmf_civicrm_removeKnownBadStringsFromAddressFields(&$msg) {
  // Remove known dummy data.
  if ($msg['street_address'] === 'N0NE PROVIDED') {
    $msg['street_address'] = '';
  }

  $invalidAddressStrings = array('0', 'City/Town', 'NoCity', 'City');
  foreach (array('postal_code', 'city') as $fieldName) {
    if (in_array($msg[$fieldName], $invalidAddressStrings)) {
      $msg[$fieldName] = '';
    }
  }
}

/**
 * Get the name value for the option group for direct mail.
 *
 * The option group for the direct mail field has been given a distinctive title but
 * the name (which is the unique one) is distinctly historical.
 *
 * This name is included (as per below) in the install script so this function exists mostly
 * to document it as such a wierd name is guaranteed to get people worried about avoiding
 * hard-coding. The more appealing title 'Appeal' cannot be guaranteed to be unique.
 *
 * @throws \CiviCRM_API3_Exception
 */
function wmf_civicrm_get_direct_mail_field_option_name()
{
    return 'appeal_20080709183729';
}

/**
 * Pulls all records in the wmf_contribution_extras table that match the gateway
 * and gateway transaction id.
 * @param string $gateway
 * @param string $gateway_txn_id
 * @return mixed array of result rows, or false if none present.
 * TODO: return empty set rather than false.
 * @throws WmfException
 */
function wmf_civicrm_get_contributions_from_gateway_id($gateway, $gateway_txn_id) {
    $gateway = strtolower( $gateway );
	$query = "SELECT cx.*, cc.* FROM wmf_contribution_extra cx LEFT JOIN civicrm_contribution cc
		ON cc.id = cx.entity_id
		WHERE gateway = %1 AND gateway_txn_id = %2";

    $dao = CRM_Core_DAO::executeQuery( $query, array(
        1 => array( $gateway, 'String' ),
        2 => array( $gateway_txn_id, 'String' ),
    ) );
	return wmf_civicrm_dao_to_list( $dao );
}

/**
 * Pulls all records in the wmf_contribution_extras table that match the civicrm
 * contribution id.
 * @param string $contribution_id
 * @return mixed array of result rows, or false if none present.
 * @throws WmfException
 */
function wmf_civicrm_get_contributions_from_contribution_id($contribution_id) {
    $query = "SELECT cx.*, cc.* FROM wmf_contribution_extra cx LEFT JOIN civicrm_contribution cc
		ON cc.id = cx.entity_id
		WHERE cc.id = %1";

    $dao = CRM_Core_DAO::executeQuery($query, array(
                1 => array($contribution_id, 'Integer'),
            ));
    return wmf_civicrm_dao_to_list($dao);
}

/**
 * Checks to see whether a contribution is refunded or charged back by gateway
 * and gateway transaction id.
 * @param string $gateway
 * @param string $gateway_txn_id
 * @return bool true if contribution exists and is refunded or charged back, else false
 */
function wmf_civicrm_is_refunded_by_gateway_id( $gateway, $gateway_txn_id ) {
	$contributions = wmf_civicrm_get_contributions_from_gateway_id( $gateway, $gateway_txn_id );
	if ( !$contributions ) {
		return false;
	}
	return CRM_Contribute_BAO_Contribution::isContributionStatusNegative(
		$contributions[0]['contribution_status_id']
	);
}


/**
 * Checks to see whether a contribution is refunded or charged back by
 * contribution id.
 * @param string $contribution_id
 * @return true if contribution exists and is refunded or charged back, else false
 */
function wmf_civicrm_is_refunded_by_contribution_id($contribution_id) {
	try {
		$statusId = civicrm_api3( 'Contribution', 'getvalue', array(
			'id' => $contribution_id,
			'return' => 'contribution_status_id'
		) );
	}
	catch ( CiviCRM_API3_Exception $e ) {
		return false;
	}
	return CRM_Contribute_BAO_Contribution::isContributionStatusNegative( $statusId );
}

function wmf_civicrm_boost_performance() {
    civicrm_initialize();
    $config = CRM_Core_Config::singleton();
    $config->doNotResetCache = 1;
}

function wmf_civicrm_set_no_thank_you( $contribution_id, $reason ) {
	watchdog( 'wmf_civicrm', "Preventing thank-you for contribution {$contribution_id} because: {$reason}", array(), WATCHDOG_INFO );

	try {
		wmf_civicrm_set_custom_field_values( $contribution_id, array(
			'no_thank_you' => $reason,
		) );
	} catch ( WmfException $ex ) {
		watchdog( 'wmf_civicrm', "Updating with no-thank-you failed with details: {$ex->getMessage()}", array(), WATCHDOG_ERROR );
	}
}

/**
 * Sets the civi records to reflect a contribution refund.
 *
 * The original contribution is set to status "Refunded", or "Chargeback" and a negative financial
 * transaction record is created. If the amount refunded does not match a second contribution is added for the balance.
 * The parent_contribution_id custom field is set on the balance contribution to connect it to the parent.
 *
 * Prior to the 4.6 CiviCRM upgrade refunds resulted in second contribution with a negative amount. They were linked
 * to the original through the parent_contribution_id custom field. This was consistent with 4.2 behaviour which was
 * the then current version.
 *
 * 4.3 (included in the 4.6 upgrade) introduced recording multiple financial transactions (payments) against
 * one contribution. In order to adapt to this the markRefund function now records second financial transactions
 * against the original contribution (using
 * the contribution.create api). Discussion about this change is at https://phabricator.wikimedia.org/T116317
 *
 * Some refunds do not have the same $ amount as the original transaction. Prior to Oct 2014 these were
 * seemingly always imported to CiviCRM.
 * Since that time the code was changed to throw an exception when the refund exceeded the original amount, and not import it
 * into CiviCRM. (this does have visibility as it results in fail_mail).
 *
 * The code suggested an intention to record mismatched refunds with a the difference in the custom fields settlement_usd.
 * However, this returns no rows. select * from wmf_contribution_extra WHERE settlement_usd IS NOT NULL LIMIT.
 * It would appear they have been recorded without any record of the discrepancy, or there were none.
 *
 * That issue should be addressed (as a separate issue). The methodology for recording the difference needs to be
 * considered e.g T89437 - preferably in conjunction with getting the appropriate method tested within the core codebase.
 *
 * Note that really core CiviCRM should have a way of handling this and we should work on getting that resolved and adopting it.
 *
 * An earlier iteration of this function reconstructed the value of the original contribution when it had been zero'd
 * or marked as 'RFD'. This appears to be last used several years ago & this handling has been removed now.
 *
 * @param int $contribution_id
 * @param string $refund_type
 *   'refund'|'chargeback' - this will determine the new contribution status.
 * @param bool $refund_completed
 *   It turns out this is only passed in as anything other than true from the tests (based on grepping).
 *   The UI DOES allow for a status of 'Pending Refund' to be used if this is required from the UI although we
 *   don't have a process around that at this stage.
 * @param string $refund_date
 * @param int $refund_gateway_txn_id
 * @param string $refund_currency
 *   If provided this will be checked against the original contribution and an exception will be thrown
 *   on mismatch.
 * @param float $refund_amount
 *   If provided this will be checked against the original contribution and an exception will be thrown
 *   on mismatch.
 *
 * @return int
 *   The refund's contribution id.
 * @throws \ExchangeRatesException
 * @throws \WmfException
 */

function wmf_civicrm_mark_refund(
    $contribution_id,
    $refund_type = 'refund',
    $refund_completed = false,
    $refund_date = null,
    $refund_gateway_txn_id = null,
    $refund_currency = null,
    $refund_amount = null
) {
    $amount_scammed = 0;

    try {
      $contribution = civicrm_api3('Contribution', 'getsingle', array(
        'id' => $contribution_id,
        'return' => array(
          'total_amount',
          'trxn_id',
          'contribution_source',
          'contact_id',
          'receive_date',
          'contribution_status_id'
        )
      ));
    }
    catch (CiviCRM_API3_Exception $e) {
      throw new WmfException(
        'INVALID_MESSAGE', "Could not load contribution: $contribution_id with error " . $e->getMessage()
      );
    }

    // Note that my usual reservation about using BAO functions from custom code is overridden by the
    // caching problems we are hitting in testing (plus the happy knowledge the tests care about this line of
    // code).
    if (CRM_Contribute_BAO_Contribution::isContributionStatusNegative($contribution['contribution_status_id'])
    ) {
        throw new WmfException( 'DUPLICATE_CONTRIBUTION', "Contribution is already refunded: $contribution_id" );
    }
    // Deal with any discrepancies in the refunded amount.
    list( $original_currency, $original_amount ) = explode(" ", $contribution['contribution_source']);

    if ( $refund_currency !== null ) {
        if ( $refund_currency != $original_currency ) {
            throw new WmfException( 'INVALID_MESSAGE', "Refund was in a different currency.  Freaking out." );
        }
    } else {
        $refund_currency = $original_currency;
    }
    if ( $refund_date === null ) {
        $refund_date = time();
    }
    elseif ( !is_numeric( $refund_date ) ) {
        $refund_date = wmf_common_date_parse_string( $refund_date );
    }

    // TODO: Normalize earlier.
    $validTypes = array(
        'refund' => 'Refunded',
        'chargeback' => 'Chargeback',
        'cancel' => 'Cancelled',
        'reversal' => 'Chargeback', // from the audit processor
        'admin_fraud_reversal' => 'Chargeback', // raw IPN code
    );

    if ( !array_key_exists( $refund_type, $validTypes ) ) {
        throw new WmfException( 'IMPORT_CONTRIB', "Unknown refund type '{$refund_type}'" );
    }

    try {
      civicrm_api3('Contribution', 'create', array(
        'id' => $contribution_id,
        'debug' => 1,
        'contribution_status_id' => $validTypes[$refund_type],
        'cancel_date' => wmf_common_date_unix_to_civicrm($refund_date),
        'refund_trxn_id' => $refund_gateway_txn_id,
      ));
    }
    catch (CiviCRM_API3_Exception $e) {
      throw new WmfException(
        'IMPORT_CONTRIB',
        "Cannot mark original contribution as refunded:
                $contribution_id, " . $e->getMessage() . print_r($e->getExtraParams(), TRUE)
      );
    }

    if ( $refund_amount !== null ) {

        $amount_scammed = round( $refund_amount, 2 ) - round( $original_amount, 2 );
        if ( $amount_scammed != 0 ) {
            $transaction = WmfTransaction::from_unique_id($contribution['trxn_id']);
            if ( $refund_gateway_txn_id ) {
              $transaction->gateway_txn_id = $refund_gateway_txn_id;
            }
            $transaction->is_refund = true;
            $refund_unique_id = $transaction->get_unique_id();

            try {
              civicrm_api3('Contribution', 'create', array(
                'total_amount' => round(
                    exchange_rate_convert(
                      $refund_currency,
                      -$amount_scammed,
                      wmf_common_date_parse_string(date('Y-m-d h:i:s', $refund_date)
                  )), 2),
                // New type?
                'financial_type_id' => 'Refund',
                'contact_id' => $contribution['contact_id'],
                'contribution_source' => $refund_currency . " " . -$amount_scammed,
                'trxn_id' => $refund_unique_id,
                'receive_date' => date('Y-m-d h:i:s', $refund_date),
                'currency' => 'USD',
                'debug' => 1,
                wmf_civicrm_get_custom_field_name('parent_contribution_id') => $contribution_id,
                wmf_civicrm_get_custom_field_name('no_thank_you') => 1,
              ));
            }
            catch (CiviCRM_API3_Exception $e) {
              throw new WmfException(
                'IMPORT_CONTRIB',
                "Cannot create new contribution for the refund difference:
                $contribution_id, " . $e->getMessage() . print_r($e->getExtraParams(), TRUE)
            );
          }
        }
    }

    if ($amount_scammed > 0) {
      wmf_common_failmail('wmf_civicrm', "Refund amount mismatch for : $contribution_id, difference is {$amount_scammed}. See "
        . CRM_Utils_System::url('civicrm/contact/view/contribution', array('reset' => 1, 'id' => $contribution_id, 'action' => 'view'), TRUE));
    }

    return $contribution_id;
}

/**
 * Update civi records to track gateway status change events.
 *
 * If more recent information is in the database, ignore the event
 * unless it is a Refund.
 *
 * For refund events, mark the refund using our helper function.
 *
 * Raw gateway status is stored in a custom field.
 * @param int $contribution_id
 * @param string $raw_status
 * @param string $normalized_status
 * @param int $timestamp
 * @throws WmfException
 */
function wmf_civicrm_set_gateway_status( $contribution_id, $raw_status, $normalized_status = null, $timestamp = null )
{
    civicrm_initialize();

    if ( $normalized_status !== null ) {
        $contribution = new CRM_Contribute_BAO_Contribution();
        $contribution->id = $contribution_id;
        if ( !$contribution->find( true ) ) {
            throw new WmfException( 'INVALID_MESSAGE', "Contribution not found: $contribution_id" );
        }

        $status_id = civicrm_api_contribution_status( $normalized_status );
        if ( $status_id === null ) {
            watchdog('wmf_civicrm', "Normalized status does not exist: {$normalized_status}", array(), WATCHDOG_ERROR);
        }
    }

    // this is sort of audit-specific logic
    if ( $normalized_status === 'Refunded' ) {
        // We restore the old status id in case this refund action was less recent
        // than current info in the db.  If the data conditional below succeeds, we
        // set the status to 'refunded' again.
        $old_status_id = $contribution->contribution_status_id;
        try {
            wmf_civicrm_mark_refund( $contribution_id, 'chargeback', true );
        } catch ( WmfException $e ) {
            watchdog('wmf_civicrm', "Cannot create a refund for: {$contribution_id}", array(), WATCHDOG_ERROR);
        }
        $contribution->find( true );
        $contribution->contribution_status_id = $old_status_id;
        $contribution->save();
    }

    if ( $timestamp === null ) {
        $gateway_date = gmdate( 'YmdHis' );
    } else {
        $gateway_date = gmdate( 'YmdHis', $timestamp );
    }

    $original_custom_values = wmf_civicrm_get_custom_values( $contribution_id, array(
        'gateway_date',
    ) );
    $last_timestamp = wmf_common_date_parse_string( $original_custom_values['gateway_date'] );
    $last_gateway_date = wmf_common_date_unix_to_sql( $last_timestamp );

    if ( $last_gateway_date >= $gateway_date ) {
        watchdog('wmf_civicrm', "Not updating contribution, because a more recent gateway status change has been recorded: {$contribution_id}", array(), WATCHDOG_INFO);
        return;
    }

    $custom_values['gateway_date'] = $gateway_date;
    $custom_values['gateway_status_raw'] = $raw_status;
    wmf_civicrm_set_custom_field_values($contribution_id, $custom_values);

    if ( $normalized_status !== null ) {
        $contribution->contribution_status_id = $status_id;
    }
    $contribution->save();
}

/**
 * Implementation of hook_civicrm_merge().
 *
 * @param string $type
 * @param array $refs
 * @param int $mainId
 * @param int $otherId
 * @param array $tables
 */
function wmf_civicrm_civicrm_merge( $type, &$refs, $mainId, $otherId, $tables ) {
    switch ( $type ) {
      case 'batch' :
      case 'form' :

        $refs['migration_info']['context'] = $type;
        CRM_Core_DAO::executeQuery('SET @uniqueID = %1', array(1 => array(uniqid() . CRM_Utils_String::createRandom(CRM_Utils_String::ALPHANUMERIC, 4), 'String')));
        if (isset($refs['fields_in_conflict'])){
          $wmfCalculatedFields = wmf_civicrm_get_calculated_fields();
          foreach ($wmfCalculatedFields as $wmfCalculatedField) {
            $keyString = 'move_' . $wmfCalculatedField;
            if (array_key_exists($keyString, $refs['fields_in_conflict'])) {
              unset($refs['fields_in_conflict'][$keyString]);
              if ($wmfCalculatedField == wmf_civicrm_get_custom_field_name('do_not_solicit')) {
                $refs['migration_info']['move_' . wmf_civicrm_get_custom_field_name('do_not_solicit')] = 1;
                $refs['migration_info']['rows']['move_' . wmf_civicrm_get_custom_field_name('do_not_solicit')]['other'] = ts('Yes');
              }
            }
          }

          // If type is 'form' then the user is responsible for selecting how to merge the
          // non-calculated fields but in batch mode we have selected assumptions
          // ie. take the latest address and give opt out choices priority over
          // default settings for opt out fields.
          if ($type === 'batch') {
            foreach (array_keys($refs['fields_in_conflict']) as $moveField) {
              if (_wmf_civicrm_merge_is_communication_boolean($moveField)) {
                unset($refs['fields_in_conflict'][$moveField]);
                $refs['migration_info'][$moveField] = 1;
                $refs['migration_info']['rows'][$moveField]['other'] = ts('Yes');
                continue;
              }

              if ($moveField == 'move_contact_source') {
                unset($refs['fields_in_conflict'][$moveField]);
                continue;
              }

              if (_wmf_civicrm_merge_resolve_preferred_language_conflict(
                str_replace('move_', '', $moveField),
                $refs['migration_info'][$moveField],
                $refs['migration_info']['rows'][$moveField]['other'],
                $refs['migration_info']['rows'][$moveField]['main'],
                $mainId,
                $otherId
              )) {
                unset($refs['fields_in_conflict'][$moveField]);
                continue;
              }

              if (_wmf_civicrm_merge_resolve_casing_conflict(
                str_replace('move_', '', $moveField),
                $refs['migration_info'][$moveField],
                $refs['migration_info']['rows'][$moveField]['other'],
                $refs['migration_info']['rows'][$moveField]['main'])) {
                  unset($refs['fields_in_conflict'][$moveField]);
                  continue;
              }

              if (_wmf_civicrm_merge_resolve_diacritic_conflict(
                str_replace('move_', '', $moveField),
                $refs['migration_info'][$moveField],
                $refs['migration_info']['rows'][$moveField]['other'],
                $refs['migration_info']['rows'][$moveField]['main'])) {
                unset($refs['fields_in_conflict'][$moveField]);
                continue;
              }

              if (substr($moveField, 0, 13) === 'move_location') {
                if (!isset($refs['is_major_gift'])) {
                  $refs['is_major_gift'] = _wmf_civicrm_is_merged_contact_major_donor($mainId, $otherId);
                }
                if (!$refs['is_major_gift']) {
                  $fieldParts = explode('_', $moveField);
                  if ($fieldParts[2] == 'email') {
                    $mainIsOnHold = $refs['migration_info']['main_details']['location_blocks']['email'][$fieldParts[3]]['on_hold'];
                    $otherIsOnHold = $refs['migration_info']['other_details']['location_blocks']['email'][$fieldParts[3]]['on_hold'];
                    if ($mainIsOnHold + $otherIsOnHold === 1) {
                      // One is one hold & the other isn't - conflict.
                      continue;
                    }
                  }
                  unset($refs['fields_in_conflict'][$moveField]);
                }

              }
            }
          }
        }

        // Only bother to calculate the totals if we are already starting to merge.
        if (empty($refs['fields_in_conflict'])) {
          wmf_civicrm_add_calculated_fields_to_migration_info($refs['migration_info'], $mainId, $otherId);
        }
        break;

    }
}

/**
 * Is this one of the communication boolean fields.
 *
 * If it is we will give 'opt out' precedence as that indicates a conscious choice.
 *
 * @param string $moveField
 *
 * @return bool
 */
function _wmf_civicrm_merge_is_communication_boolean($moveField) {
  if (in_array($moveField, array(
    'move_do_not_email',
    'move_is_opt_out',
    'move_do_not_mail',
    'move_do_not_phone',
    'move_do_not_sms'
  ))) {
    return TRUE;
  }
  return FALSE;
}

/**
 * Resolve conflicts that are only about name casing.
 *
 * If we have a conflict of 'Sarah' vs 'sarah' vs 'SARAH' we choose the one with
 * the least number of capitals, that is not all lower case.
 *
 * This is not perfect but only on edge cases would another choice be better and,
 * importantly, all these variants have been entered at some point deliberately.
 *
 * The most common poor-data-options are not using the caps key at all, or having
 * caps lock on - so this formula prefers mixed caps.
 *
 * If we find a match we need to alter the $moveFieldValue & $valueToKeep vars.
 * That is not hugely logical but unfortunately the hook interaction has been organic
 * and until we started using batch merge was not actually tested in core.
 *
 * @param string $fieldName
 * @param string $moveFieldValue
 * @param string $valueToKeep
 * @param string $valueToOverwrite
 *
 * @return bool
 */
function _wmf_civicrm_merge_resolve_casing_conflict($fieldName, &$moveFieldValue, &$valueToKeep, &$valueToOverwrite) {
  $fieldsToResolveCasingFor = array('last_name', 'first_name');
  if (!in_array(str_replace('move_', '', $fieldName), $fieldsToResolveCasingFor)) {
    return FALSE;
  }
  // Let's get rid of any preceding or trailing spaces.
  $valueToKeep = trim($valueToKeep);
  $valueToOverwrite = trim($valueToOverwrite);
  $moveFieldValue = trim($moveFieldValue);

  if (strtoupper($valueToKeep) != strtoupper($valueToOverwrite)) {
    return FALSE;
  }
  $capitalsInToKeepValue =  _wmf_civicrm_count_capital_letters($valueToKeep);
  $capitalsInToOverwriteValue =  _wmf_civicrm_count_capital_letters($valueToOverwrite);

  if ($capitalsInToOverwriteValue === 0 || ($capitalsInToKeepValue > 0 && $capitalsInToKeepValue < $capitalsInToOverwriteValue)) {
    // We have a conflict to resolve and we are going to resolve it
    // by keeping the default copy behaviour.
    return TRUE;
  }
  // We have a conflict to resolve and we are going to resolve it by keeping
  //the value that was to be overwritten.
  $moveFieldValue = $valueToOverwrite;
  $valueToKeep = $valueToOverwrite;
  return TRUE;
}

/**
 * Resolve conflicts that are only about diacritic vs english characters casing.
 *
 * If we have a conflict of 'Jose' vs 'Jos' chose the one with a diacritic character.
 *
 * If we find a match we need to alter the $moveFieldValue & $valueToKeep vars.
 * That is not hugely logical but unfortunately the hook interaction has been organic
 * and until we started using batch merge was not actually tested in core.
 *
 * @param string $fieldName
 * @param string $moveFieldValue
 * @param string $valueToKeep
 * @param string $valueToOverwrite
 *
 * @return bool
 */
function _wmf_civicrm_merge_resolve_diacritic_conflict($fieldName, &$moveFieldValue, &$valueToKeep, &$valueToOverwrite) {
  $fieldsToResolve = array('last_name', 'first_name');
  if (!in_array(str_replace('move_', '', $fieldName), $fieldsToResolve)) {
    return FALSE;
  }
  // Let's get rid of any preceding or trailing spaces.
  $valueToKeep = trim($valueToKeep);
  $valueToOverwrite = trim($valueToOverwrite);
  $moveFieldValue = trim($moveFieldValue);
  if (strtoupper(wmf_civicrm_normalizeUtf8String($valueToKeep)) != strtoupper(wmf_civicrm_normalizeUtf8String($valueToOverwrite))) {
    return FALSE;
  }

  if (wmf_civicrm_is_utf_normalised($valueToOverwrite)) {
    // We have a conflict to resolve and we are going to resolve it
    // by keeping the default copy behaviour, since the value to overwrite is the one without diacritics
    // (AKA isNormalised).
    return TRUE;
  }
  // We have a conflict to resolve and we are going to resolve it by keeping
  //the value that was to be overwritten.
  $moveFieldValue = $valueToOverwrite;
  $valueToKeep = $valueToOverwrite;
  return TRUE;
}

/**
 * Check for special characters (none latin) in the string.
 *
 * @param string $string
 *
 * @return bool
 */
function wmf_civicrm_is_utf_normalised($string) {
  if (!Normalizer::isNormalized($string, Normalizer::FORM_D)) {
    return FALSE;
  }
  $s = preg_replace('@[^\0-\x80]@u',"", $string);
  if ($s !== $string) {
    return FALSE;
  }
  return TRUE;

}

/**
 * From http://nz2.php.net/manual/en/normalizer.normalize.php
 *
 * I have since found https://core.trac.wordpress.org/browser/trunk/src/wp-includes/formatting.php#L1127
 * & packages
 * https://packagist.org/packages/neitanod/forceutf8
 * & https://packagist.org/packages/patchwork/utf8
 *
 * My feeling after viewing them is that with the change below this is safe but it
 * could be more complete. There are a few tests implemented & my inclination
 * is to deploy & iterate depending on the results.
 *
 * & perhaps might try in a second iteration taking more from that.
 *
 * @param $original_string
 * @return mixed
 */
function wmf_civicrm_normalizeUtf8String( $original_string)
{

  // maps German (umlauts) and other European characters onto two characters before just removing diacritics
  $s    = preg_replace( '@\x{00c4}@u'    , "AE",    $original_string );    // umlaut  => AE
  $s    = preg_replace( '@\x{00d6}@u'    , "OE",    $s );    // umlaut  => OE
  $s    = preg_replace( '@\x{00dc}@u'    , "UE",    $s );    // umlaut  => UE
  $s    = preg_replace( '@\x{00e4}@u'    , "ae",    $s );    // umlaut  => ae
  $s    = preg_replace( '@\x{00f6}@u'    , "oe",    $s );    // umlaut  => oe
  $s    = preg_replace( '@\x{00fc}@u'    , "ue",    $s );    // umlaut  => ue
  $s    = preg_replace( '@\x{00f1}@u'    , "ny",    $s );    //  => ny
  $s    = preg_replace( '@\x{00ff}@u'    , "yu",    $s );    //  => yu


  // maps special characters (characters with diacritics) on their base-character followed by the diacritical mark
  // exmaple:   => U,   => a`
  $s    = Normalizer::normalize( $s, Normalizer::FORM_D );


  $s    = preg_replace( '@\pM@u'        , "",    $s );    // removes diacritics


  $s    = preg_replace( '@\x{00df}@u'    , "ss",    $s );    // maps German  onto ss
  $s    = preg_replace( '@\x{00c6}@u'    , "AE",    $s );    //  => AE
  $s    = preg_replace( '@\x{00e6}@u'    , "ae",    $s );    //  => ae
  $s    = preg_replace( '@\x{0132}@u'    , "IJ",    $s );    // ? => IJ
  $s    = preg_replace( '@\x{0133}@u'    , "ij",    $s );    // ? => ij
  $s    = preg_replace( '@\x{0152}@u'    , "OE",    $s );    //  => OE
  $s    = preg_replace( '@\x{0153}@u'    , "oe",    $s );    //  => oe

  $s    = preg_replace( '@\x{00d0}@u'    , "D",    $s );    //  => D
  $s    = preg_replace( '@\x{0110}@u'    , "D",    $s );    //  => D
  $s    = preg_replace( '@\x{00f0}@u'    , "d",    $s );    //  => d
  $s    = preg_replace( '@\x{0111}@u'    , "d",    $s );    // d => d
  $s    = preg_replace( '@\x{0126}@u'    , "H",    $s );    // H => H
  $s    = preg_replace( '@\x{0127}@u'    , "h",    $s );    // h => h
  $s    = preg_replace( '@\x{0131}@u'    , "i",    $s );    // i => i
  $s    = preg_replace( '@\x{0138}@u'    , "k",    $s );    // ? => k
  $s    = preg_replace( '@\x{013f}@u'    , "L",    $s );    // ? => L
  $s    = preg_replace( '@\x{0141}@u'    , "L",    $s );    // L => L
  $s    = preg_replace( '@\x{0140}@u'    , "l",    $s );    // ? => l
  $s    = preg_replace( '@\x{0142}@u'    , "l",    $s );    // l => l
  $s    = preg_replace( '@\x{014a}@u'    , "N",    $s );    // ? => N
  $s    = preg_replace( '@\x{0149}@u'    , "n",    $s );    // ? => n
  $s    = preg_replace( '@\x{014b}@u'    , "n",    $s );    // ? => n
  $s    = preg_replace( '@\x{00d8}@u'    , "O",    $s );    //  => O
  $s    = preg_replace( '@\x{00f8}@u'    , "o",    $s );    //  => o
  $s    = preg_replace( '@\x{017f}@u'    , "s",    $s );    // ? => s
  $s    = preg_replace( '@\x{00de}@u'    , "T",    $s );    //  => T
  $s    = preg_replace( '@\x{0166}@u'    , "T",    $s );    // T => T
  $s    = preg_replace( '@\x{00fe}@u'    , "t",    $s );    //  => t
  $s    = preg_replace( '@\x{0167}@u'    , "t",    $s );    // t => t

  // remove all non-ASCii characters
  // This is in the original function but is too broad. There is a test that will fail
  // if you remove this.
  // $s    = preg_replace( '@[^\0-\x80]@u'    , "",    $s );

  // possible errors in UTF8-regular-expressions
  if (empty($s))
    return $original_string;
  else
    return $s;
}

/**
 * Resolve conflicts on preferred language.
 *
 * If the underlying language (first 2 letters) is the same we make a value choice.
 *
 * 1) we prefer 'valid' languages - ones that have entries in the option_value table.
 * 2) we prefer more explicit (longer) languages (en_US over en).
 * 3) we prefer languages with labels that describe them. For example
 *   'de_DE' => 'German' has been deliberately created
 *   'de_NZ' => 'de_NZ' has been code-created.
 *
 * Note preferring based on the option value table means updates to what is enabled
 * or whether they have labels will flow through.
 *
 * We could also return the later donor but this feels like poor return on effort given they are
 * already the same main language and we don't easily have that info at this point in the code.
 * We will usually get the most recent donor anyway by default - as it merges higher id to lower id.
 *
 * @param string $fieldName
 * @param string $moveFieldValue
 * @param string $valueToKeep
 * @param string $valueToOverwrite
 *
 * @return bool
 *   Has the conflict been resolved?
 */
function _wmf_civicrm_merge_resolve_preferred_language_conflict($fieldName, &$moveFieldValue, &$valueToKeep, &$valueToOverwrite, $contactToKeepID, $contactToDeleteID) {
  if ($fieldName !== 'preferred_language') {
    return FALSE;
  }

  if (substr($valueToKeep, 0, 2) != substr($valueToOverwrite, 0, 2)) {
    $lastDonor = civicrm_api3('Contribution', 'getvalue', array(
      'return' => 'contact_id',
      'contact_id' => array('IN' => array($contactToKeepID, $contactToDeleteID)),
      'options' => array('sort' => 'receive_date DESC', 'limit' => 1),
    ));
    if ($lastDonor == $contactToKeepID) {
      // We are resolving the conflict by keeping the language unchanged from our 'keeper' contact.
      // By default it will be trying to overwrite that value with the 'to-delete' contact
      // (and it would block that through the conflict process).
      // We re-instate the values that it was going to overwrite.
      $moveFieldValue = $valueToOverwrite;
      $valueToKeep = $valueToOverwrite;
      return TRUE;
    }
    else {
      // We are resolving the conflict by keeping the language from our 'to-delete' contact.
      // These are what it was going to carry over & we keep that.
      return TRUE;
    }
  }
  if (!wmf_civicrm_check_language_exists($valueToOverwrite)) {
    // The conflict is resolved & the value to keep is fine.
    return TRUE;
  }

  $languages = wmf_civicrm_get_valid_languages();
  if (!wmf_civicrm_check_language_exists($valueToKeep)
    || strlen($valueToOverwrite) > strlen($valueToKeep)
    || ($languages[$valueToKeep] == $valueToKeep && $languages[$valueToOverwrite] != $valueToOverwrite)
  ) {
    // The conflict is resolved & we will chose the overwrite value as the keeper is invalid.
    $moveFieldValue = $valueToOverwrite;
    $valueToKeep = $valueToOverwrite;
    return TRUE;
  }

  return TRUE;
}

/**
 * Count the number of capital letters in a string.
 *
 * @param $string
 *
 * @return int
 */
function _wmf_civicrm_count_capital_letters($string) {
  return strlen(preg_replace('/[^A-Z]+/', '', $string));
}

/**
 * Has the combined contact given $500 or more?
 *
 * @param int $mainId
 * @param int $otherId
 *
 * @return bool
 *
 * @throws \CiviCRM_API3_Exception
 */
function _wmf_civicrm_is_merged_contact_major_donor($mainId, $otherId) {
  $total = 0;
  $donations = civicrm_api3('Contribution', 'get', array(
    'return' => 'total_amount',
    'contact_id' => array('IN' => array($mainId, $otherId)),
  ));
  foreach ($donations['values'] as $donation) {
    $total += $donation['total_amount'];
  }
  return ($total >= 500) ? TRUE : FALSE;
}

/**
 *
 * We are testing a nuanced real life situation where the address data of the
 * most recent donor gets priority - resulting in the primary address being set
 * to the primary address of the most recent donor and address data on a per
 * location type basis also being set to the most recent donor. Hook also excludes
 * a fully matching address with a different location.
 *
 * This has been added to the test suite to ensure the code supports more this
 * type of intervention.
 *
 * @param array $blocksDAO
 *   Array of location DAO to be saved. These are arrays in 2 keys 'update' & 'delete'.
 * @param int $mainId
 *   Contact_id of the contact that survives the merge.
 * @param int $otherId
 *   Contact_id of the contact that will be absorbed and deleted.
 * @param array $migrationInfo
 *   Calculated migration info, informational only.
 *
 * @return mixed
 */
function wmf_civicrm_civicrm_alterLocationMergeData(&$blocksDAO, $mainId, $otherId, $migrationInfo) {

  // If we are dealing with a manual merge do not intervene.
  if ($migrationInfo['context'] == 'form') {
    return;
  }
  $lastDonor = civicrm_api3('Contribution', 'get', array(
    'return' => 'contact_id',
    'contact_id' => array('IN' => array($mainId, $otherId)),
    'options' => array('sort' => 'receive_date DESC', 'limit' => 1),
  ));
  if (!$lastDonor['count']) {
    return;
  }
  $lastDonorID = $lastDonor['values'][$lastDonor['id']]['contact_id'];
  // Since the last donor is not the main ID we are prioritising info from the last donor.
  // In the test this should always be true - but keep the check in case
  // something changes that we need to detect.
  if ($lastDonorID != $mainId) {
    $higherPriorityLocationBlocks = _wmf_civicrm_clean_duplicate_location_from_merge_blocks($migrationInfo['other_details']['location_blocks']);
    $lowerPriorityLocationBlocks = $migrationInfo['main_details']['location_blocks'];

    foreach ($higherPriorityLocationBlocks as $blockType => $blocks) {
      foreach ($blocks as $block) {
        if ($block['is_primary'] == 1 && isset($blocksDAO[$blockType]['update'][$block['id']])) {
          unset($blocksDAO[$blockType]['update'][$block['id']]->is_primary);
        }

        if (empty($lowerPriorityLocationBlocks[$blockType])) {
          continue;
        }

        foreach ($lowerPriorityLocationBlocks[$blockType] as $index => $lowerPriorityLocationBlock) {
          if (_wmf_civicrm_is_delete_location_in_favour_of_higher_priority_one(
            $blocks, $block, $lowerPriorityLocationBlock)
          ) {
            $blocksDAO[$blockType]['delete'][$lowerPriorityLocationBlock['id']] = _civicrm_api3_load_DAO($blockType);
            $blocksDAO[$blockType]['delete'][$lowerPriorityLocationBlock['id']]->id = $lowerPriorityLocationBlock['id'];
            if (!isset($blocksDAO[$blockType]['update'][$block['id']])) {
              $blocksDAO[$blockType]['update'][$block['id']] = _civicrm_api3_load_DAO($blockType);
              $blocksDAO[$blockType]['update'][$block['id']]->id = $block['id'];
              $blocksDAO[$blockType]['update'][$block['id']]->contact_id = $mainId;
            }
            unset($lowerPriorityLocationBlocks[$blockType][$index]);
          }
          if (isset($blocksDAO[$blockType]['update'][$block['id']]->is_primary)) {
            $blocksDAO[$blockType]['update'][$block['id']]->is_primary = $block['is_primary'];
          }
        }
        foreach ($lowerPriorityLocationBlocks[$blockType] as $remainingLocation) {
          $blocksDAO[$blockType]['update'][$remainingLocation['id']] = _civicrm_api3_load_DAO($blockType);
          $blocksDAO[$blockType]['update'][$remainingLocation['id']]->id = $remainingLocation['id'];
          $blocksDAO[$blockType]['update'][$remainingLocation['id']]->contact_id = $mainId;
          $blocksDAO[$blockType]['update'][$remainingLocation['id']]->is_primary = 0;
        }
      }
    }
  }
}

/**
 * Clean up any instances of 2 identical home addresses before processing.
 *
 * It's not valid to have 2 addresses of the same location type in CiviCRM.
 * However, they seem to still be coming in so for now ensure they don't cause
 * issues when deduping, with the is_primary flag being lost.
 *
 * T145873
 *
 * @param array $blocks
 *   An array of locations associated with a contact. These are keyed by entity
 *   (email, address, phone) and under that an array of db entries.
 *
 * @return array
 *   Blocks, possibly with some removed.
 */
function _wmf_civicrm_clean_duplicate_location_from_merge_blocks($blocks) {
  foreach ($blocks as $entity => $locationBlocks) {
    $locations = array();
    $primaryID = NULL;
    foreach ($locationBlocks as $index => $locationBlock) {
      $locations[$locationBlock['location_type_id']][$index] = $locationBlock['id'];
      if ($locationBlock['is_primary']) {
        $primaryID = $locationBlock['id'];
      }
    }
    foreach ($locations as $locationsOfType) {
      if (count($locationsOfType) > 1) {
        // We have a duplicate.
        foreach ($locationsOfType as $index => $locationID) {
          if ($locationID <> $primaryID) {
            unset($blocks[$entity][$index]);
          }
        }
      }
    }
  }
  return $blocks;
}

/**
 * Add the calculated fields to the migration info when merging.
 *
 * The contributions have already been merged so we can query the DB for this info. We
 * are safeguarded against change by the test in our mergeTest although it makes sense to add
 * a similar test upstream too.
 *
 * Doing this here rather than post merge means there are less changes to these values, meaning it
 * is easier to revert.
 *
 * @param array $migrationInfo
 * @param int $contactID
 * @params int $otherID
 *   ID of the contact to be deleted.
 */
function wmf_civicrm_add_calculated_fields_to_migration_info(&$migrationInfo, $contactID, $otherID) {
  $select = "
    SELECT
      SUM(total_amount) AS lifetime_usd_total,
      MAX(receive_date) AS last_donation_date,
      SUM(COALESCE(total_amount, 0)) as total_usd_amount
   ";
  for ($year = WMF_MIN_ROLLUP_YEAR; $year <= WMF_MAX_ROLLUP_YEAR; $year++) {
    $nextYear = $year + 1;
    $select .= ", MAX(IF(receive_date BETWEEN '{$year}-07-01' AND '{$nextYear}-06-30 23:59:59', 1, 0)) as is_{$year}_donor";
  }
  $query = $select . "
    FROM
      civicrm_contribution c
      LEFT JOIN wmf_contribution_extra x ON x.entity_id = c.contact_id
      WHERE contact_id  IN ($contactID, $otherID)
  ";
  $result = CRM_Core_DAO::executeQuery($query);
  $migrationInfo = _wmf_civicrm_add_result_fields_to_migration_info($migrationInfo, $result);
  if (!isset($migrationInfo['move_' . wmf_civicrm_get_custom_field_name('last_donation_date')])) {
    return;
  }
  $query = "
    SELECT
      COALESCE(x.original_currency, currency) as last_donation_currency,
      COALESCE(x.original_amount, total_amount) as last_donation_amount,
      total_amount as last_donation_usd

    FROM
      civicrm_contribution c
      LEFT JOIN wmf_contribution_extra x ON x.entity_id = c.id
      WHERE contact_id  IN ($contactID, $otherID) AND receive_date = %1 LIMIT 1";

  $lastDate = $migrationInfo['move_' . wmf_civicrm_get_custom_field_name('last_donation_date')];
  $result = CRM_Core_DAO::executeQuery($query, array(
    1 => array($lastDate,
    'String'
  )));
  $migrationInfo = _wmf_civicrm_add_result_fields_to_migration_info($migrationInfo, $result);
}

/**
 * @param $migrationInfo
 * @param $result
 * @return mixed
 */
function _wmf_civicrm_add_result_fields_to_migration_info($migrationInfo, $result) {
  $result->fetch();
  foreach (wmf_get_calculated_field_names() as $field) {
    if (isset($result->$field)) {
      $migrationInfo['move_' . wmf_civicrm_get_custom_field_name($field)] = $result->$field;
    }
  }
  return $migrationInfo;
}

/**
 * Get the field ids of the wmf fields that are determined by calculation.
 *
 * Differences in these fields should not block a merge activity as they
 * are simply recalculated.
 *
 * @return array
 *   The custom fields that are calculated in the format
 *   - custom_1
 *   - custom_2
 */
function wmf_civicrm_get_calculated_fields() {
  $fieldNames = wmf_get_calculated_field_names();
  $fieldNames[] = 'do_not_solicit';
  $customFields = array();
  foreach ($fieldNames as $fieldName) {
    $customFields[] = wmf_civicrm_get_custom_field_name($fieldName);
  }
  return $customFields;
}

/**
 * Get the names of the calculated fields.
 *
 * @return array
 */
function wmf_get_calculated_field_names() {
  $fieldNames = array(
    'last_donation_date',
    'last_donation_currency',
    'last_donation_amount',
    'last_donation_usd',
    'lifetime_usd_total',
  );
  for ($year = WMF_MIN_ROLLUP_YEAR; $year <= WMF_MAX_ROLLUP_YEAR; $year++) {
    $fieldNames[] = 'is_' . $year . '_donor';
  }
  return $fieldNames;
}

/**
 * Implementation of hook_civicrm_post, used to update contribution_extra fields
 * and wmf_donor rollup fields.
 */
function wmf_civicrm_civicrm_post( $op, $type, $id, &$entity ) {
	switch( $type ) {
		case 'Contribution':
			wmf_civicrm_civicrm_post_Contribution( $op, $id, $entity );
			break;
	}
}


/**
 * Implementation of hook_civicrm_pre, used to geocode US addresses
 */
function wmf_civicrm_civicrm_pre( $op, $type, $id, &$entity ) {
	switch( $type ) {
		case 'Address':
			wmf_civicrm_civicrm_pre_Address( $op, $entity );
			break;
	}
}

/**
 * Fill in the calculated donor fields for a given donor.
 *
 * @param int $contactID
 */
function wmf_civicrm_calculate_donor_fields($contactID) {
  $queries[] = "INSERT INTO wmf_donor( entity_id, last_donation_date, lifetime_usd_total ) (
            SELECT contact_id, MAX(receive_date) AS last_donation_date, SUM(total_amount) AS lifetime_usd_total
            FROM civicrm_contribution
            WHERE contact_id = $contactID
            GROUP by contact_id
        ) ON DUPLICATE KEY UPDATE
            last_donation_date = VALUES(last_donation_date),
            lifetime_usd_total = VALUES(lifetime_usd_total)";

  $queries[] = "UPDATE wmf_donor w
        JOIN civicrm_contribution t
            ON t.contact_id = w.entity_id
            AND t.contact_id = $contactID
            AND t.receive_date = w.last_donation_date
        JOIN wmf_contribution_extra x
            ON x.entity_id = t.id
        SET w.last_donation_usd = t.total_amount,
            w.last_donation_amount = x.original_amount,
            w.last_donation_currency = x.original_currency";

  for ( $year = WMF_MIN_ROLLUP_YEAR; $year <= WMF_MAX_ROLLUP_YEAR; $year++ ) {
    $next_year = $year + 1;
    $queries[] = "UPDATE wmf_donor w
            JOIN civicrm_contribution t
                ON t.contact_id = w.entity_id
                AND t.contact_id = $contactID
                AND t.receive_date >= '$year-07-01'
                AND t.receive_date < '$next_year-07-01'
            SET w.is_{$year}_donor = 1";
  };
  foreach ($queries as $query) {
    CRM_Core_DAO::executeQuery($query);
  }
}

/**
 * Geocode US addresses using wmf_zip_geo. Adds latitude, longitude,
 * and timezone as GMT offset.
 *
 * @param string $op Type of operation being performed
 * @param array $address Values being submitted
 */
function wmf_civicrm_civicrm_pre_Address( $op, &$address ) {
	static $usId = null;
	if ( $usId == null ) {
		$usId = wmf_civicrm_get_country_id( 'US' );
	};

	switch ( $op ) {
		case 'create':
		case 'edit':
			$geoData = array();

			// Do we have any geo info for this address?
			if (
				!empty($address['country_id']) &&  $address['country_id']== $usId &&
				!empty( $address['postal_code'] )
			) {
				$sql = "SELECT city, s.id AS state_id, latitude, longitude, timezone
					FROM wmf_zip_geo g
					JOIN civicrm_state_province s ON s.abbreviation = g.state
					    AND s.country_id = $usId
					WHERE zip = %1";

				$result = CRM_Core_DAO::executeQuery(
					$sql,
					array( 1 => array(
						substr( trim( $address['postal_code'] ), 0, 5 ),
						'String'
					) )
				);
				if ( $result->fetch() ) {
					$geoData = array(
						'geo_code_1' => $result->latitude,
						'geo_code_2' => $result->longitude,
						'timezone' => $result->timezone,
					);
					// Only overwrite city and state if empty
					if ( empty( $address['city'] ) ) {
						$geoData['city'] = $result->city;
					}
					if (empty($address['state_province_id']) || $address['state_province_id'] == 'null') {
						$geoData['state_province_id'] = $result->state_id;
					}
				}
			}
			if ( empty( $geoData ) && $op == 'edit' ) {
				// Blank out any outdated information on edit
				$geoData = array(
					'geo_code_1' => '',
					'geo_code_2' => '',
					'timezone' => '',
				);
			}
			$address = array_merge( $address, $geoData );
	}
}
function wmf_civicrm_civicrm_post_Contribution( $op, $id, &$contribution ) {
	switch ( $op ) {
	case 'create':
	case 'edit':
		$extra = array();

		if ( $contribution->trxn_id ) {
			try {
				$transaction = WmfTransaction::from_unique_id( $contribution->trxn_id );
				$extra['gateway'] = strtolower( $transaction->gateway );
				$extra['gateway_txn_id'] = $transaction->gateway_txn_id;
			} catch ( WmfException $ex ) {
				watchdog( 'wmf_civicrm', "Failed to parse trxn_id: {$contribution->trxn_id}, " . $ex->getMessage() );
			}
		}

		if ( $contribution->source ) {
			list( $original_currency, $original_amount ) = explode( " ", $contribution->source );
			if ( is_numeric( $original_amount ) && wmf_civicrm_is_valid_currency( $original_currency ) ) {
				$extra['original_currency'] = $original_currency;
				$extra['original_amount'] = $original_amount;
			} else {
				$extra['original_currency'] = 'USD';
				$extra['original_amount'] = $contribution->total_amount;
			}
		}

		if ( $extra ) {
			wmf_civicrm_set_custom_field_values( $id, $extra );
		}

		// If we're missing any of the data we need for wmf_donor, retrieve it
		// from the database.
		if( $contribution->contact_id
			&& $contribution->total_amount
			&& $contribution->receive_date ) {
			$receive_date = $contribution->receive_date;
			$contact_id = $contribution->contact_id;
			$total_amount = $contribution->total_amount;
		} else {
			try {
				$db_contribution = civicrm_api3('Contribution', 'getsingle', array(
					'id' => $contribution->id,
					'return' => array('contact_id', 'total_amount', 'receive_date'),
				));
			}
			catch (CiviCRM_API3_Exception $e) {
				// can't get the data, skip wmf_donor updates
				break;
			}
			$receive_date = $db_contribution['receive_date'];
			$contact_id = $db_contribution['contact_id'];
			$total_amount = $db_contribution['total_amount'];
		}

		// Update the wmf_donor data.  Set the is_YYYY_donor column to true
		// FIXME: if this is an edit, we should review all contributions
		$wmf_donor = array();
		$contribution_date = new DateTime( $receive_date );
		$isNegative = (($contribution->total_amount < 0) || CRM_Contribute_BAO_Contribution::isContributionStatusNegative( $contribution->contribution_status_id));
		$fiscal_year = intval( $contribution_date->format( 'Y' ) );
		if ( intval( $contribution_date->format( 'm' ) ) < 7 ) {
			$fiscal_year = $fiscal_year - 1;
		}
		if ( $fiscal_year >= WMF_MIN_ROLLUP_YEAR && $fiscal_year <= WMF_MAX_ROLLUP_YEAR ) {
			if ( !$isNegative ) {
				$wmf_donor["is_{$fiscal_year}_donor"] = 1;
			} else {
			  $donationsCount = civicrm_api3('Contribution', 'getcount', array(
				'contact_id' => $contact_id,
				'contribution_status_id' => 'Completed',
				'receive_date' => array('BETWEEN' => array($fiscal_year . '-07-01', $fiscal_year +1 . '-06-30')),
				'total_amount' => array('>' => 0),
			  ));
			  $wmf_donor["is_{$fiscal_year}_donor"] = $donationsCount ? 1 : 0;
			}
		}

		// Update the latest donation data.
		// If this is an edit, first check if it's the latest
		$latest = true;

		if ( $op === 'edit' ) {
			$latestDate = wmf_civicrm_most_recent_completed_contribution_date($contact_id);
			if (strtotime($latestDate) > strtotime($receive_date) || $isNegative) {
				$latest = false;
			}
		}
		if ( $latest ) {
			$wmf_donor['last_donation_date'] = $contribution_date->format( 'YmdHis' );
			$wmf_donor['last_donation_usd'] = $total_amount;
			if ( isset( $extra['original_currency'] ) ) {
				$wmf_donor['last_donation_currency'] = $extra['original_currency'];
			}
			if ( isset( $extra['original_amount'] ) && $extra['original_amount'] > 0) {
				$wmf_donor['last_donation_amount'] = $extra['original_amount'];
			}
		}
		if ( $isNegative && !empty($latestDate)) {
			$latestContribution = wmf_civicrm_get_single_contribution_for_contact_by_date($contact_id, $latestDate);
			$wmf_donor['last_donation_date'] = date('YmdHis', strtotime($latestContribution['receive_date']));
			$wmf_donor['last_donation_usd'] =  $latestContribution['total_amount'];
			if ( isset( $latestContribution['contribution_source'] ) ) {
				$source = explode(' ', $latestContribution['contribution_source']);
				$wmf_donor['last_donation_currency'] = $source[0];
				$wmf_donor['last_donation_amount'] = $source[1];
			}
		}
		// Get lifetime totals.
		// Note that in 4.7 a new field is_payment is added to the financial_trxn table.
		// We should probably switch to that at that point.
		// For now from_financial_account_id IS NULL seems to filter out the fee lines.
		$sql = <<<EOS
SELECT SUM(t.total_amount) AS lifetime_usd_total
FROM civicrm_contribution c
LEFT JOIN `civicrm_entity_financial_trxn`eft ON eft.`entity_id` = c.id
AND eft.entity_table = 'civicrm_contribution'
LEFT JOIN civicrm_financial_trxn t ON t.id = eft.financial_trxn_id
WHERE contact_id = {$contact_id}
AND from_financial_account_id IS NULL
GROUP BY contact_id
EOS;

		if ( ( $lifetimeTotal = CRM_Core_DAO::singleValueQuery( $sql ) ) !== FALSE ) {
			$wmf_donor['lifetime_usd_total'] = $lifetimeTotal;
		}
		if ( !empty( $wmf_donor ) ) {
			wmf_civicrm_set_custom_field_values(
				$contact_id,
				$wmf_donor,
				'wmf_donor'
			);
		}
		break;
	}
}

/**
 * Implements hook_alterLogTables().
 *
 * @param array $logTableSpec
 */
function wmf_civicrm_civicrm_alterLogTables(&$logTableSpec) {
  $logTableSpec['wmf_donor'] = array();
  $logTableSpec['wmf_contribution_extra'] = array();
  $contactReferences = CRM_Dedupe_Merger::cidRefs();
  foreach (array_keys($logTableSpec) as $tableName) {
    $contactIndexes = array();
    $logTableSpec[$tableName]['engine'] = 'INNODB';
    $logTableSpec[$tableName]['engine_config'] = 'ROW_FORMAT=COMPRESSED KEY_BLOCK_SIZE=4';
    $contactRefsForTable = CRM_Utils_Array::value($tableName, $contactReferences, array());
    foreach ($contactRefsForTable as $fieldName) {
      $contactIndexes['index_' . $fieldName] = $fieldName;
    }
    $logTableSpec[$tableName]['indexes'] = array_merge(array(
      'index_id' => 'id',
      'index_log_conn_id' => 'log_conn_id',
      'index_log_date' => 'log_date',
    ), $contactIndexes);
  }
}

/**
 * Check if any completed contributions exist for the contact after the provided date.
 *
 * @param int $contact_id
 *
 * @return string $contribution_date
 */
function wmf_civicrm_most_recent_completed_contribution_date($contact_id) {
  $completedStatusID = civicrm_api_contribution_status('Completed');
  return CRM_Core_DAO::singleValueQuery("
    SELECT max(receive_date) FROM civicrm_contribution
    WHERE contact_id = {$contact_id}
    AND contribution_status_id = $completedStatusID
    AND total_amount > 0
  ");
}

/**
 * Check if any completed contributions exist for the contact after the provided date.
 *
 * @param int $contact_id
 * @param string $contribution_date
 *
 * @return string $contribution_date
 */
function wmf_civicrm_get_single_contribution_for_contact_by_date($contact_id, $contribution_date) {
  return civicrm_api3('Contribution', 'getsingle', array(
    'contact_id' => $contact_id,
    'receive_date' => $contribution_date,
    'contribution_status_id' => 'Completed',
    'total_amount' => array('>' => 0),
    'return' => array('receive_date', 'total_amount', 'source'),
  ));
}

/**
 * Get a grip on multiple database connections.
 *
 * @return db_switcher
 */
function wmf_civicrm_get_dbs() {
    return new db_switcher();
}

/**
 * Expand CiviCRM DAO results object into an array of rows as array
 *
 * @param $dao CRM_Core_DAO
 *
 * @return array
 */
function wmf_civicrm_dao_to_list( $dao ) {
    if ( PEAR::isError( $dao ) ) {
        throw new Exception( $dao->getMessage() );
    }
    $result = array();
    while ($dao->fetch()) {
        $result[] = $dao->toArray();
    }
    // FIXME: pick wart
    if (empty($result)) {
        return false;
    }
    return $result;
}

/**
 * Implements hook_civicrm_buildForm
 */
function wmf_civicrm_civicrm_buildForm( $formName, &$form ) {
    switch ( $formName ) {
      case 'CRM_Contribute_Form_Contribution':
        // Only run this validation for users having the Engage role.
        if ( !wmf_civicrm_user_has_role( 'Engage Direct Mail' ) ) {
            break;
        }

        // Default to the Engage contribution type, if this is a new contribution.
        if ( $form->_action & CRM_Core_Action::ADD ) {
            $engage_contribution_type_id = wmf_civicrm_get_civi_id( 'contribution_type_id', 'Engage' );
            $form->setDefaults( array(
                'financial_type_id' => $engage_contribution_type_id,
            ));
            $form->assign('customDataSubType', $engage_contribution_type_id);
        }

        // Make Batch Number required, if the field exists.
        $batch_num_field_name = wmf_civicrm_evil_get_custom_field_in_form( 'import_batch_number', $form->_elementIndex );
        if ( $batch_num_field_name ) {
            $form->addRule( $batch_num_field_name, t('Batch number is required'), 'required' );
        }
        break;

      case 'CRM_Contact_Form_Search_Advanced' :
      case 'CRM_Contribute_Form_Search' :
        $defaults['contribution_date_relative'] = 0;
        $form->setDefaults($defaults);
        break;
    }
}

/**
 * Additional validations for the contribution form
 * @return array of any errors in the form
 */
function wmf_civicrm_validate_contribution( $fields, $form ) {
    $errors = array();

    // Only run on add or update
    if ( ! ( $form->_action & ( CRM_Core_Action::UPDATE | CRM_Core_Action::ADD ) ) ) {
        return $errors;
    }
    // Source has to be of the form USD 15.25 so as not to gum up the works,
    // and the currency code on the front should be something we understand
    $source = $fields['source'];
    if ( preg_match( '/^([a-z]{3}) [0-9]+(\.[0-9]+)?$/i', $source, $matches ) ) {
        $currency = strtoupper( $matches[1] );
        if ( !wmf_civicrm_is_valid_currency( $currency ) ) {
            $errors['source'] = t( 'Please set a supported currency code' );
        }
    } else {
        $errors['source'] = t( 'Source must be in the format USD 15.25' );
    }

    // Only run the following validation for users having the Engage role.
    if ( !wmf_civicrm_user_has_role( 'Engage Direct Mail' ) ) {
        return $errors;
    }

    $engage_contribution_type_id = wmf_civicrm_get_civi_id( 'financial_type_id', 'Engage' );
    if ( $fields['financial_type_id'] !== $engage_contribution_type_id ) {
        $errors['financial_type_id'] = t("Must use the \"Engage\" contribution type.");
    }

    // Gift Source (sic field named "Campaign") is limited.
    $gift_source_field_name = wmf_civicrm_evil_get_custom_field_in_form( 'Campaign', $fields );
    if ( $gift_source_field_name ) {
        $allowed_sources = array(
            'Combined Federal Campaign',
            'Benefactor Gift',
            'Community Gift',
            'Donor Advised Fund',
            'Matching Gift',
            'Payroll Deduction',
        );
        if ( !in_array( $fields[$gift_source_field_name], $allowed_sources ) ) {
            $errors[$gift_source_field_name] = t('Must choose a Gift Source from the following list: ') . implode( ', ', $allowed_sources );
        }
    }

	if ( wmf_civicrm_tomorrows_month() === '01' ) {
		$postmark_field_name = wmf_civicrm_evil_get_custom_field_in_form( 'postmark_date', $fields );
		// If the receive_date is in Dec or Jan, make sure we have a postmark date,
		// to be generous to donors' tax stuff.
		$date = strptime( $fields['receive_date'], "%m/%d/%Y" );
		// n.b.: 0-based date spoiler.
		if ( $date['tm_mon'] == (12 - 1) || $date['tm_mon'] == (1 - 1) ) {
			// And the postmark date is missing
			if ( !$fields[$postmark_field_name] ) {
				$errors[$postmark_field_name] = t("You forgot the postmark date!");
			}
		}
	}

    return $errors;
}

/**
 * Return tomorrow's month number.  Used to tell if today is New Year's Eve or
 * later.
 */
function wmf_civicrm_tomorrows_month() {
	$tomorrow = new DateTime('+1 day');
	$month = gmdate("m", $tomorrow->getTimestamp());
	return $month;
}

/**
 * Return true if the user has this role
 *
 * @param string $role Name of the role
 *
 * @return bool
 */
function wmf_civicrm_user_has_role( $role ) {
    global $user;

    foreach ( $user->roles as $rid => $roleName ) {
        if ( $role === $roleName ) {
            return true;
        }
    }

    return false;
}

/**
 * @param string $name custom field name
 * @param array $fields k/v fields as they are passed to CiviCRM form hooks
 *
 * @return string evil mangled name, like "custom_21_123332"
 */
function wmf_civicrm_evil_get_custom_field_in_form( $name, $fields ) {
    $custom_field_stump = wmf_civicrm_get_custom_field_name( $name ) . '_';
    foreach ( $fields as $key => $value ) {
        if ( 0 === strpos( $key, $custom_field_stump ) ) {
            return $key;
        }
    }
    watchdog( 'wmf_civicrm', 'Form is missing your precious custom field.', NULL, WATCHDOG_ERROR );
    return null;
}

/**
 * Split a full name into first and last
 *
 * Splits at the first space, cos we currently want the first name for emails,
 * so we err on the side of not pulling in middle names.
 *
 * TODO: this is always a bad idea, there is no correct way to split names.
 * Rework any templates or code that assumes a binomial.
 *
 * @param string $full_name
 *
 * @return array [first_name, last_name]
 */
function wmf_civicrm_janky_split_name( $full_name ) {
    $names = preg_split( '/\s+/', $full_name, 2 );
    if ( count( $names ) == 1 ) {
        $names[] = '';
    }
    return $names;
}

/**
 * Recalculates USD amounts of contributions between $start and $end
 * based on exchange rates in our database.  Useful if you spent three months
 * not retrieving the latest exchange rates.
 *
 * @param DateTime $start the date from which to start recalculation
 * @param DateTime $end the cutoff date
 * @param int $batch_size number of contributions to recalculate at once
 */
function wmf_civicrm_recalculate_contributions( $start, $end, $batch_size = 1000 ) {
	$api = civicrm_api_classapi();
	$query = "SELECT c.id, c.receive_date, c.total_amount, c.fee_amount,
c.net_amount, e.original_amount, e.original_currency
FROM civicrm_contribution c
JOIN wmf_contribution_extra e on e.entity_id = c.id
WHERE c.receive_date > %1
AND c.receive_date <= %2
AND c.id > %3
AND e.original_currency <> 'USD'
ORDER BY c.id ASC
LIMIT %4";
	$last_id = 0;
	while ( true ) {
		$dao = CRM_Core_DAO::executeQuery( $query, array(
			1 => array( $start->format( 'Ymd' ), 'Date' ),
			2 => array( $end->format( 'Ymd' ), 'Date' ),
			3 => array( $last_id, 'Integer' ),
			4 => array( $batch_size, 'Integer' )
		) );
		$batch = wmf_civicrm_dao_to_list( $dao );
		if ( empty( $batch ) ) {
			break;
		}

		foreach ( $batch as $contribution ) {
			$id = $contribution['id'];
			$original_amount = $contribution['original_amount'];
			$currency = $contribution['original_currency'];
			$total_amount = $contribution['total_amount'];

			if ( $id > $last_id ) {
				$last_id = $id;
			}

			if ( $original_amount == 0 || $total_amount == 0 ) {
				watchdog( 'recalculate_contributions', "Not recalculating contribution $id with zero original or total amount", null, WATCHDOG_DEBUG );
				continue;
			}
			if ( !preg_match( '/^[a-z][a-z][a-z]$/i', $currency ) ) {
				watchdog( 'recalculate_contributions', "Not recalculating contribution $id with nonsense currency $currency", null, WATCHDOG_DEBUG );
				continue;
			}

			// Approximate rate we originally used so we can correct the fee & net.
			$rate_used = $total_amount / $original_amount;
			try {
				$correct_rate = exchange_rate_convert( $currency, 1, wmf_common_date_parse_string( $contribution['receive_date'] ) );
			}
			catch ( ExchangeRatesException $ex ) {
				watchdog( 'recalculate_contributions', "Not recalculating contribution $id.  Cannot find rate for currency $currency", null, WATCHDOG_DEBUG );
				continue;
			}
			$recalculated_total = round( $correct_rate * $original_amount, 2 );
			$recalculated_fee = round( $contribution['fee_amount'] / $rate_used * $correct_rate, 2 );
			$recalculated_net = $recalculated_total - $recalculated_fee;

			$params = array(
				'id' => $contribution['id'],
				'total_amount' => $recalculated_total,
				'fee_amount' => $recalculated_fee,
				'net_amount' => $recalculated_net
			);

			watchdog(
				'recalculate_contributions',
				"Recalculating contribution $id, received on {$contribution['receive_date']}. " .
				"Original_amount: $original_amount, original_currency: $currency, " .
				"old total_amount: $total_amount, old fee_amount: {$contribution['fee_amount']}, " .
				"old net_amount: {$contribution['net_amount']}.  " .
				"New total_amount: $recalculated_total, new fee_amount: $recalculated_fee, " .
				"new net_amount: $recalculated_net.",
				null,
				WATCHDOG_DEBUG
			);

			if ( !$api->Contribution->Create( $params ) ) {
				throw new WmfException( 'recalculate_contributions', "Failed to update USD amount of contribution: $id, " . db_error() );
			}
		}
	}
}

/**
 * Get options for a field.
 *
 * @param string $entity
 * @param string $field
 *
 * @return array
 * @throws \CiviCRM_API3_Exception
 */
function wmf_civicrm_get_options($entity, $field) {
    if (!isset(\Civi::$statics['wmf_civicrm'][$entity][$field])) {
      $options = civicrm_api3($entity, 'getoptions', array('field' => $field));
      \Civi::$statics['wmf_civicrm'][$entity][$field] = $options['values'];
    }
    return \Civi::$statics['wmf_civicrm'][$entity][$field];
}

/**
 * Get options for a field.
 *
 * @param string $entity
 * @param string $field
 * @param string $key
 *
 * @return array
 * @throws \CiviCRM_API3_Exception
 */
function wmf_civicrm_get_option($entity, $field, $key) {
  $options = wmf_civicrm_get_options($entity, $field);
  return array_search($key, $options);
}

/**
 * Fills in the appear field with any data that might be missing from it.
 * @param string $startDate
 */
function wmf_civicrm_fill_missing_appeal_data($startDate) {
  civicrm_initialize();
  $customGroup = civicrm_api3('CustomGroup', 'getsingle', array('name' => 'Gift_Data'));
  $optionGroupID = civicrm_api3('OptionGroup', 'getvalue', array(
    'name' => wmf_civicrm_get_direct_mail_field_option_name(),
    'return' => 'id',
  ));
  global $databases;
  $drupalDbName = $databases['default']['default']['database'];
  CRM_Core_DAO::executeQuery("
    UPDATE
    {$customGroup['table_name']} v
    LEFT JOIN {$drupalDbName}.contribution_tracking t ON v.entity_id = t.contribution_id
    LEFT JOIN civicrm_contribution c ON c.id = contribution_id

    SET v.appeal = utm_campaign

    WHERE
      t.ts > '{$startDate}' AND
      c.id IS NOT NULL
      AND (v.appeal IS NULL OR v.appeal = '')
      AND utm_campaign IN (
        SELECT value COLLATE utf8_unicode_ci FROM civicrm_option_value ov WHERE ov.option_group_id= {$optionGroupID} AND is_active = 1
      )
  ");

  CRM_Core_DAO::executeQuery("
    INSERT INTO
    {$customGroup['table_name']} (entity_id, appeal)

    SELECT contribution_id, utm_campaign
    FROM {$drupalDbName}.contribution_tracking
    LEFT JOIN civicrm_contribution c ON c.id = contribution_id
    LEFT JOIN {$customGroup['table_name']} v ON v.entity_id = contribution_id

    WHERE
      ts > '{$startDate}' AND
      c.id IS NOT NULL
      AND v.id IS NULL
      AND utm_campaign IN (
        SELECT value COLLATE utf8_unicode_ci FROM civicrm_option_value ov WHERE ov.option_group_id= {$optionGroupID} AND is_active = 1
      )
  ");

}

/**
 * Determine if a code represents a supported currency. Uses the
 * DonationInterface currency list as a canonical source.
 * @param string $currency should be an ISO 4217 code
 * @return bool true if it's a real currency that we can handle
 */
function wmf_civicrm_is_valid_currency( $currency ) {
	$all_currencies = array_keys( CurrencyRates::getCurrencyRates() );
	return in_array( $currency, $all_currencies );
}


/**
 * Implements hook_civicrm_validateForm().
 *
 * @param string $formName
 * @param array $fields
 * @param array $files
 * @param CRM_Core_Form $form
 * @param array $errors
 */
function wmf_civicrm_civicrm_validateForm($formName, &$fields, &$files, &$form, &$errors) {
  if ($formName === 'CRM_Contact_Form_DedupeFind') {
    if (!$fields['limit']) {
      $errors['limit'] = ts('Save the database. Use a limit');
    }
  }
  if ($formName == 'CRM_Contribute_Form_Contribution') {
    $engageErrors = wmf_civicrm_validate_contribution($fields, $form);
    if (!empty($engageErrors)) {
      $errors = array_merge($errors, $engageErrors);
    }
  }
}

/**
 * Block users from accessing the dedupe page without a limit.
 *
 * @param CRM_Core_Page $page
 */
function wmf_civicrm_civicrm_pageRun(&$page) {
  if (get_class($page) == 'CRM_Contact_Page_DedupeFind') {
    $action = $page->get('action');
    if (!CRM_Utils_Request::retrieve('limit', 'Integer') && ($action != CRM_Core_Action::PREVIEW)) {
      CRM_Core_Error::statusBounce(ts('The dedupe page can only be accessed with a limit. How did you get there without one? Tell fr-tech'), 'civicrm/contact/deduperules?reset=1');
    }
  }

}/**
 * @param array $blocks
 * @param array $lowerPriorityLocationBlock
 * @param array $block
 *
 * @return array
 */
  function _wmf_civicrm_is_delete_location_in_favour_of_higher_priority_one($blocks, $block, $lowerPriorityLocationBlock) {
    // If the address is an exact match for any address on the preferred contact or matches the location
    // type of an existing address we want to delete it.
    $lowerPriorityLocationTypeID = $lowerPriorityLocationBlock['location_type_id'];
    unset($lowerPriorityLocationBlock['location_type_id']);
    if ($lowerPriorityLocationTypeID == $block['location_type_id'] ||
      CRM_Dedupe_Merger::locationIsSame($block, $lowerPriorityLocationBlock)
      && (!isset($blocks['update']) || !isset($blocks['update'][$lowerPriorityLocationBlock['id']]))
      && (!isset($blocks['delete']) || !isset($blocks['delete'][$lowerPriorityLocationBlock['id']]))
    ) {
      return TRUE;
    }
    return FALSE;
  }

  /**
   * Given a line from a drupal watchdog log with an array, reconstruct
   * the keys and values from the mangled print_r variant
   * e.g. [gateway] =&gt; paypal#012    [source_name] =&gt; SmashPig#012
   */
  function wmf_civicrm_parse_watchdog_array( $logLine ) {
    $logLine = str_replace( '=&gt;', '=>', $logLine );
    $output = [];
    preg_match_all( '/\[([^\]]+)\] => (.*?)#012/', $logLine, $matches);
    foreach( $matches[1] as $index => $key ) {
      $output[$key] = $matches[2][$index];
    }
    return $output;
  }

/**
 * Flush statically cached option values.
 */
  function wmf_civicrm_flush_cached_options() {
    \Civi::$statics['wmf_civicrm'] = array();
  }
