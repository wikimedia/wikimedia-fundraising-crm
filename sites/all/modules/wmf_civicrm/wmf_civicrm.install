<?php

require_once(__DIR__ . "/bootstrap.inc");

function wmf_civicrm_install() {
  wmf_civicrm_update_7000();
  wmf_civicrm_update_7001();
  wmf_civicrm_update_7002();
  wmf_civicrm_update_7003();
  wmf_civicrm_update_7004();
  wmf_civicrm_update_7005();
  wmf_civicrm_update_7006();
  wmf_civicrm_update_7007();
  wmf_civicrm_update_7008();
  wmf_civicrm_update_7009();
  wmf_civicrm_update_7010();
  wmf_civicrm_update_7011();
  wmf_civicrm_update_7012();
  wmf_civicrm_update_7013();
  wmf_civicrm_update_7014();
  wmf_civicrm_update_7015();
  wmf_civicrm_update_7016();
  wmf_civicrm_update_7017();
  wmf_civicrm_update_7021();
  wmf_civicrm_update_7022();
  wmf_civicrm_update_7023();
  wmf_civicrm_update_7024();
  wmf_civicrm_update_7025();
  wmf_civicrm_update_7027();
  wmf_civicrm_update_7028();
  wmf_civicrm_update_7029();
  wmf_civicrm_update_7030();
  wmf_civicrm_update_7031();
  wmf_civicrm_update_7032();
  wmf_civicrm_update_7060();
  wmf_civicrm_update_7061();
  wmf_civicrm_update_7062();
  wmf_civicrm_update_7063();
  wmf_civicrm_update_7064();
  wmf_civicrm_update_7080();
  wmf_civicrm_update_7090();
  wmf_civicrm_update_7100();
  wmf_civicrm_update_7110();
  wmf_civicrm_update_7120();
  wmf_civicrm_update_7170();
  wmf_civicrm_update_7180();
  wmf_civicrm_update_7190();
  wmf_civicrm_update_7200();
  wmf_civicrm_update_7205();
  wmf_civicrm_update_7210();
  wmf_civicrm_update_7230();
  wmf_civicrm_update_7235();
  wmf_civicrm_update_7280();
  wmf_civicrm_update_7290();
  wmf_civicrm_update_7300();
  wmf_civicrm_update_7310();
  wmf_civicrm_update_7455();
  wmf_civicrm_update_7460();
  wmf_civicrm_update_7524();
  wmf_civicrm_update_7525();
  wmf_civicrm_update_7526();
  wmf_civicrm_update_7530();
  wmf_civicrm_update_7570();
  wmf_civicrm_update_7575();
  wmf_civicrm_update_7580();
  wmf_civicrm_update_7585();
  wmf_civicrm_update_7605();
  wmf_civicrm_update_7610();
  wmf_civicrm_update_7615();
}

/**
 * Helper creates a new option group and links an
 * existing custom field in the Gift_Data custom group.
 *
 * TODO this is not a handy generalization, just a way
 * to have a little less copypasta in this file.  I also
 * suspect there's a better place for it to live.
 */
function _link_gift_data_field_to_new_group($field_name, $group_name, $values) {
  $api = wmf_civicrm_bootstrap_civi();

  // Get the custom group.
  $success = $api->CustomGroup->get(array(
    'name' => 'Gift_Data',
  ));
  if (!$success || !count($api->values)) {
    throw new DrupalUpdateException($api->errorMsg());
  }
  $custom_group_id = $api->values[0]->id;

  // Get the field.
  $success = $api->CustomField->get(array(
    'custom_group_id' => $custom_group_id,
    'name' => $field_name,
  ));
  if (!$success || !count($api->values)) {
    throw new DrupalUpdateException($api->errorMsg());
  }
  $custom_field_id = $api->values[0]->id;

  // Make the options.
  $success = $api->OptionGroup->get(array(
    'name' => $group_name,
  ));
  if (!$success || !count($api->values)) {
    $success = $api->OptionGroup->create(array(
      'is_active' => 1,
      'is_reserved' => 1,
      'name' => $group_name,
      'title' => $field_name,
    ));
    if (!$success) {
      throw new DrupalUpdateException($api->errorMsg());
    }
  }
  $option_group_id = $api->values[0]->id;

  foreach ($values as $value) {
    $success = $api->OptionValue->get(array(
      'group_id' => $option_group_id,
      'value' => $value,
    ));
    if (!$success || !count($api->values)) {
      $success = $api->OptionValue->create(array(
        'option_group_id' => $option_group_id,
        'label' => ts($value),
        'value' => $value,
      ));
      if (!$success) {
        throw new DrupalUpdateException($api->errorMsg());
      }
    }
  }

  // Link the options to this field.
  $success = $api->CustomField->create(array(
    'id' => $custom_field_id,
    'option_group_id' => $option_group_id,
    // TODO why do i have to reset these fields here?
    // they are set when the row is created but come
    // out as 0 after this update.
    'is_active' => 1,
    'is_required' => 1,
    'is_searchable' => 1,
  ));
  if (!$success) {
    throw new DrupalUpdateException($api->errorMsg());
  }
}

/**
 * Add contribution types and payment instruments
 */
function wmf_civicrm_update_7000() {
  $financial_types = array(
    'Cash',
    'Benevity',
  );
  wmf_civicrm_bootstrap_civi();
  require_once 'update_payment_instruments.php';
  wmf_install_add_missing_payment_instruments();
  wmf_civicrm_create_financial_types($financial_types);
}

/**
 * Add settlement date field
 */
function wmf_civicrm_update_7001() {
  $api = wmf_civicrm_bootstrap_civi();
  $api->CustomGroup->get(array(
    'name' => 'contribution_extra',
  ));
  $result = $api->values();
  if (empty($result)) {
    $success = $api->CustomGroup->create(array(
      'extends' => 'Contribution',
      'name' => 'contribution_extra',
      'table_name' => 'wmf_contribution_extra',
      'title' => ts('Contribution Extra'),
      'is_active' => 1,
    ));
    if (!$success) {
      throw new DrupalUpdateException($api->errorMsg());
    }
    $result = $api->values();
  }
  $values = $api->values();
  $custom_group = array_pop($values);

  $success = $api->CustomField->create(array(
    'custom_group_id' => $custom_group->id,
    'name' => 'settlement_date',
    'column_name' => 'settlement_date',
    'label' => ts('Settlement Date'),
    'data_type' => 'Date',
    'html_type' => 'Select Date',
    'is_active' => 1,
    'is_searchable' => 1,
    'is_search_range' => 1,
    'is_view' => 1,
    'date_format' => 'M d, yy',
    'time_format' => 2,
  ));
  if (!$success) {
    throw new DrupalUpdateException($api->errorMsg());
  }
}

/**
 * Add non-authoritatize USD conversion estimate
 */
function wmf_civicrm_update_7002() {
  $api = wmf_civicrm_bootstrap_civi();
  $success = $api->CustomGroup->get(array(
    'name' => 'contribution_extra',
  ));
  if (!$success) {
    throw new DrupalUpdateException($api->errorMsg());
  }
  $values = $api->values();
  $custom_group = array_pop($values);

  $success = $api->CustomField->create(array(
    'custom_group_id' => $custom_group->id,
    'name' => 'total_usd',
    'column_name' => 'total_usd',
    'label' => ts('Total in USD (approx)'),
    'data_type' => 'Money',
    'html_type' => 'Text',
    'is_active' => 1,
    'is_searchable' => 1,
    'is_search_range' => 1,
    'is_view' => 1,
  ));
  if (!$success) {
    throw new DrupalUpdateException($api->errorMsg());
  }
}

function wmf_civicrm_update_7003() {
  wmf_civicrm_bootstrap_civi();
  wmf_civicrm_create_financial_types(array(
    'Merkle',
  ));
}

/**
 * Add gateway_account name field
 */
function wmf_civicrm_update_7004() {
  $api = wmf_civicrm_bootstrap_civi();
  $success = $api->CustomGroup->get(array(
    'name' => 'contribution_extra',
  ));
  if (!$success) {
    throw new DrupalUpdateException($api->errorMsg());
  }
  $values = $api->values();
  $custom_group = array_pop($values);

  $success = $api->CustomField->create(array(
    'custom_group_id' => $custom_group->id,
    'name' => 'gateway_account',
    'column_name' => 'gateway_account',
    'label' => ts('Gateway Account Name'),
    'data_type' => 'String',
    'html_type' => 'Text',
    'is_active' => 1,
    'is_searchable' => 1,
    'is_view' => 1,
  ));
  if (!$success) {
    throw new DrupalUpdateException($api->errorMsg());
  }
}

/**
 * More complete gateway and settlement recording. Adding a field to mark
 * auditing-only transactions, and a hack to link contributions.
 */
function wmf_civicrm_update_7005() {
  $api = wmf_civicrm_bootstrap_civi();
  $success = $api->CustomGroup->get(array(
    'name' => 'contribution_extra',
  ));
  if (!$success) {
    throw new DrupalUpdateException($api->errorMsg());
  }
  $values = $api->values();
  $custom_group = array_pop($values);

  $success = $api->CustomField->create(array(
    'custom_group_id' => $custom_group->id,
    'name' => 'gateway',
    'column_name' => 'gateway',
    'label' => ts('Gateway'),
    'data_type' => 'String',
    'html_type' => 'Text',
    'is_active' => 1,
    'is_searchable' => 1,
    'is_view' => 1,
  ));
  if (!$success) {
    throw new DrupalUpdateException($api->errorMsg());
  }

  $success = $api->CustomField->create(array(
    'custom_group_id' => $custom_group->id,
    'name' => 'gateway_txn_id',
    'column_name' => 'gateway_txn_id',
    'label' => ts('Gateway Transaction ID'),
    'data_type' => 'String',
    'html_type' => 'Text',
    'is_active' => 1,
    'is_searchable' => 1,
    'is_view' => 1,
  ));
  if (!$success) {
    throw new DrupalUpdateException($api->errorMsg());
  }

  $success = $api->CustomField->create(array(
    'custom_group_id' => $custom_group->id,
    'name' => 'gateway_status_raw',
    'column_name' => 'gateway_status_raw',
    'label' => ts('Gateway Status (raw)'),
    'data_type' => 'String',
    'html_type' => 'Text',
    'is_active' => 1,
    'is_searchable' => 1,
    'is_view' => 1,
  ));
  if (!$success) {
    throw new DrupalUpdateException($api->errorMsg());
  }

  $success = $api->CustomField->create(array(
    'custom_group_id' => $custom_group->id,
    'name' => 'gateway_status',
    'column_name' => 'gateway_status',
    'label' => ts('Gateway Status (normalized)'),
    'data_type' => 'String',
    'html_type' => 'Text',
    'is_active' => 1,
    'is_searchable' => 1,
    'is_view' => 1,
  ));
  if (!$success) {
    throw new DrupalUpdateException($api->errorMsg());
  }

  $success = $api->CustomField->create(array(
    'custom_group_id' => $custom_group->id,
    'name' => 'gateway_date',
    'column_name' => 'gateway_date',
    'label' => ts('Gateway Last Update Timestamp'),
    'data_type' => 'Date',
    'html_type' => 'Select Date',
    'is_active' => 1,
    'is_searchable' => 1,
    'is_search_range' => 1,
    'is_view' => 1,
    'date_format' => 'M d, yy',
    'time_format' => 2,
  ));
  if (!$success) {
    throw new DrupalUpdateException($api->errorMsg());
  }

  $success = $api->CustomField->create(array(
    'custom_group_id' => $custom_group->id,
    'name' => 'original_amount',
    'column_name' => 'original_amount',
    'label' => ts('Original Amount Received (unconverted)'),
    'data_type' => 'Money',
    'html_type' => 'Text',
    'is_active' => 1,
    'is_searchable' => 1,
    'is_search_range' => 1,
    'is_view' => 1,
  ));
  if (!$success) {
    throw new DrupalUpdateException($api->errorMsg());
  }

  $success = $api->CustomField->create(array(
    'custom_group_id' => $custom_group->id,
    'name' => 'original_currency',
    'column_name' => 'original_currency',
    'label' => ts('Original Currency Received'),
    'data_type' => 'String',
    'html_type' => 'Text',
    'is_active' => 1,
    'is_searchable' => 1,
    'is_view' => 1,
  ));
  if (!$success) {
    throw new DrupalUpdateException($api->errorMsg());
  }

  $success = $api->CustomField->create(array(
    'custom_group_id' => $custom_group->id,
    'name' => 'settlement_usd',
    'column_name' => 'settlement_usd',
    'label' => ts('Settlement Total (USD)'),
    'data_type' => 'Money',
    'html_type' => 'Text',
    'is_active' => 1,
    'is_searchable' => 1,
    'is_search_range' => 1,
    'is_view' => 1,
  ));
  if (!$success) {
    throw new DrupalUpdateException($api->errorMsg());
  }

  $success = $api->CustomField->create(array(
    'custom_group_id' => $custom_group->id,
    'name' => 'settlement_currency',
    'column_name' => 'settlement_currency',
    'label' => ts('Settlement Currency'),
    'data_type' => 'String',
    'html_type' => 'Text',
    'is_active' => 1,
    'is_searchable' => 1,
    'is_view' => 1,
  ));
  if (!$success) {
    throw new DrupalUpdateException($api->errorMsg());
  }

  $success = $api->CustomField->create(array(
    'custom_group_id' => $custom_group->id,
    'name' => 'deposit_date',
    'column_name' => 'deposit_date',
    'label' => ts('Deposit Received Date'),
    'data_type' => 'Date',
    'html_type' => 'Select Date',
    'is_active' => 1,
    'is_searchable' => 1,
    'is_search_range' => 1,
    'is_view' => 1,
    'date_format' => 'M d, yy',
    'time_format' => 2,
  ));
  if (!$success) {
    throw new DrupalUpdateException($api->errorMsg());
  }

  $success = $api->CustomField->create(array(
    'custom_group_id' => $custom_group->id,
    'name' => 'deposit_usd',
    'column_name' => 'deposit_usd',
    'label' => ts('Deposit Total (USD)'),
    'data_type' => 'Money',
    'html_type' => 'Text',
    'is_active' => 1,
    'is_searchable' => 1,
    'is_search_range' => 1,
    'is_view' => 1,
  ));
  if (!$success) {
    throw new DrupalUpdateException($api->errorMsg());
  }

  $success = $api->CustomField->create(array(
    'custom_group_id' => $custom_group->id,
    'name' => 'deposit_currency',
    'column_name' => 'deposit_currency',
    'label' => ts('Deposit Currency'),
    'data_type' => 'String',
    'html_type' => 'Text',
    'is_active' => 1,
    'is_searchable' => 1,
    'is_view' => 1,
  ));
  if (!$success) {
    throw new DrupalUpdateException($api->errorMsg());
  }

  $success = $api->CustomField->create(array(
    'custom_group_id' => $custom_group->id,
    'name' => 'parent_contribution_id',
    'column_name' => 'parent_contribution_id',
    'label' => ts('Parent Contribution ID'),
    'data_type' => 'Int',
    'html_type' => 'Text',
    'is_active' => 1,
    'is_searchable' => 1,
    'is_view' => 1,
  ));
  if (!$success) {
    throw new DrupalUpdateException($api->errorMsg());
  }

  $success = $api->CustomField->create(array(
    'custom_group_id' => $custom_group->id,
    'name' => 'finance_only',
    'column_name' => 'finance_only',
    'label' => ts('Finance Auditing Only'),
    'data_type' => 'Boolean',
    'html_type' => 'Radio',
    'is_active' => 1,
    'is_searchable' => 1,
    'is_view' => 1,
  ));
  if (!$success) {
    throw new DrupalUpdateException($api->errorMsg());
  }
}

/**
 * Additional, gateway-related contribution statuses
 */
function wmf_civicrm_update_7006() {
  wmf_civicrm_create_option_values('contribution_status', array(
    'Settled',
    'Paid',
  ));

  $api = wmf_civicrm_bootstrap_civi();

  $success = $api->CustomGroup->get(array(
    'name' => 'contribution_extra',
  ));
  if (!$success) {
    throw new DrupalUpdateException($api->errorMsg());
  }
  $custom_group = $api->values[0];
  $success = $api->CustomField->get(array(
    'custom_group_id' => $custom_group->id,
    'name' => 'gateway_status',
  ));
  if ($success && $api->values) {
    $field = $api->values[0];
    $success = $api->CustomField->delete(array(
      'id' => $field->id,
    ));
    if (!$success) {
      throw new DrupalUpdateException($api->errorMsg());
    }
  }
}

/**
 * New contribution types to distinguish refunds from chargebacks. Create old
 * "Review" tag.
 */
function wmf_civicrm_update_7007() {
  $api = wmf_civicrm_bootstrap_civi();

  wmf_civicrm_create_financial_types(array(
    'Refund',
    'Chargeback',
  ));

  $success = $api->Tag->create(array(
    'name' => 'Review',
    'description' => 'Review',
  ));
  if (!$success) {
    throw new DrupalUpdateException($api->errorMsg());
  }
}

/**
 * Add new check processor!
 */
function wmf_civicrm_update_7008() {
  wmf_civicrm_bootstrap_civi();
  wmf_civicrm_create_financial_types(array(
    'Arizona Lockbox',
  ));
}

/**
 * Extend some CiviCRM column maximum lengths
 */
function wmf_civicrm_update_7009() {
  $dbs = wmf_civicrm_get_dbs();
  $dbs->push('civicrm');

  db_query("ALTER TABLE civicrm_email
            MODIFY email varchar(254) DEFAULT NULL");

  db_query("ALTER TABLE civicrm_address
            MODIFY postal_code varchar(64) DEFAULT NULL");
}

/**
 * Improve civicrm_entity_tag indexing--DO NOT RUN ON PRODUCTION
 */
function wmf_civicrm_update_7010() {
  $dbs = wmf_civicrm_get_dbs();
  $dbs->push('civicrm');

  try {
    db_query("ALTER TABLE civicrm_entity_tag
            ADD KEY entity_id (entity_id)");
  }
  catch (PDOException $ex) {
    drupal_set_message("Key already exists?: " + $ex->getMessage());
  }
}

/**
 * Improve civicrm_entity_tag indexing
 */
function wmf_civicrm_update_7011() {
  $dbs = wmf_civicrm_get_dbs();
  $dbs->push('civicrm');

  try {
    db_query("ALTER TABLE civicrm_entity_tag
            ADD KEY entity_table (entity_table)");
  }
  catch (PDOException $ex) {
    drupal_set_message("Key already exists?: " + $ex->getMessage());
  }
}

/**
 * Add source metadata fields
 */
function wmf_civicrm_update_7012() {
  $api = wmf_civicrm_bootstrap_civi();

  $success = $api->CustomGroup->get(array(
    'name' => 'contribution_extra',
  ));
  if (!$success) {
    throw new DrupalUpdateException($api->errorMsg());
  }
  $values = $api->values();
  $custom_group = array_pop($values);

  $success = $api->CustomField->create(array(
    'custom_group_id' => $custom_group->id,
    'name' => 'source_name',
    'column_name' => 'source_name',
    'label' => ts('Source Name'),
    'data_type' => 'String',
    'html_type' => 'Text',
    'is_active' => 1,
    'is_searchable' => 1,
    'is_view' => 1,
  ));
  if (!$success) {
    throw new DrupalUpdateException($api->errorMsg());
  }

  $success = $api->CustomField->create(array(
    'custom_group_id' => $custom_group->id,
    'name' => 'source_type',
    'column_name' => 'source_type',
    'label' => ts('Source Type'),
    'data_type' => 'String',
    'html_type' => 'Text',
    'is_active' => 1,
    'is_searchable' => 1,
    'is_view' => 1,
  ));
  if (!$success) {
    throw new DrupalUpdateException($api->errorMsg());
  }

  $success = $api->CustomField->create(array(
    'custom_group_id' => $custom_group->id,
    'name' => 'source_host',
    'column_name' => 'source_host',
    'label' => ts('Source Host'),
    'data_type' => 'String',
    'html_type' => 'Text',
    'is_active' => 1,
    'is_searchable' => 1,
    'is_view' => 1,
  ));
  if (!$success) {
    throw new DrupalUpdateException($api->errorMsg());
  }

  $success = $api->CustomField->create(array(
    'custom_group_id' => $custom_group->id,
    'name' => 'source_run_id',
    'column_name' => 'source_run_id',
    'label' => ts('Source Run ID'),
    'data_type' => 'String',
    'html_type' => 'Text',
    'is_active' => 1,
    'is_searchable' => 1,
    'is_view' => 1,
  ));
  if (!$success) {
    throw new DrupalUpdateException($api->errorMsg());
  }

  $success = $api->CustomField->create(array(
    'custom_group_id' => $custom_group->id,
    'name' => 'source_version',
    'column_name' => 'source_version',
    'label' => ts('Source Version'),
    'data_type' => 'String',
    'html_type' => 'Text',
    'is_active' => 1,
    'is_searchable' => 1,
    'is_view' => 1,
  ));
  if (!$success) {
    throw new DrupalUpdateException($api->errorMsg());
  }

  $success = $api->CustomField->create(array(
    'custom_group_id' => $custom_group->id,
    'name' => 'source_enqueued_time',
    'column_name' => 'source_enqueued_time',
    'label' => ts('Enqueued At Timestamp'),
    'data_type' => 'Date',
    'html_type' => 'Select Date',
    'is_active' => 1,
    'is_searchable' => 1,
    'is_search_range' => 1,
    'is_view' => 1,
    'date_format' => 'M d, yy',
    'time_format' => 2,
  ));
  if (!$success) {
    throw new DrupalUpdateException($api->errorMsg());
  }
}

/**
 * Add Postmark Date field
 */
function wmf_civicrm_update_7013() {
  $api = wmf_civicrm_bootstrap_civi();
  $api->CustomGroup->get(array(
    'name' => 'contribution_extra',
  ));
  $values = $api->values();
  $custom_group = array_pop($values);

  $success = $api->CustomField->create(array(
    'custom_group_id' => $custom_group->id,
    'name' => 'Postmark_Date',
    'column_name' => 'postmark_date',
    'label' => ts('Postmark Date'),
    'data_type' => 'Date',
    'html_type' => 'Select Date',
    'is_active' => 1,
    'is_searchable' => 0,
    'is_view' => 0,
  ));
  if (!$success) {
    throw new DrupalUpdateException($api->errorMsg());
  }
}

/**
 * Add no_thank_you field
 */
function wmf_civicrm_update_7014() {
  $ret = array();
  $api = wmf_civicrm_bootstrap_civi();
  $api->CustomGroup->get(array(
    'name' => 'contribution_extra',
  ));
  $values = $api->values();
  $custom_group = array_pop($values);

  $success = $api->CustomField->create(array(
    'custom_group_id' => $custom_group->id,
    'name' => 'no_thank_you',
    'column_name' => 'no_thank_you',
    'label' => ts('No Thank-you Reason'),
    'data_type' => 'String',
    'html_type' => 'Text',
    'is_active' => 1,
    'is_searchable' => 1,
    'is_view' => 0,
  ));
  if (!$success) {
    throw new DrupalUpdateException($api->errorMsg());
  }

  $dbs = wmf_civicrm_get_dbs();
  $dbs->push('civicrm');

  db_query("
UPDATE wmf_contribution_extra, civicrm_contribution
SET
    no_thank_you = 'legacy'
WHERE
    wmf_contribution_extra.entity_id = civicrm_contribution.id
    AND thankyou_date = '1970-01-01 00:00:00'
");
}

/**
 * Extend contact.preferred_language column maximum length
 */
function wmf_civicrm_update_7015() {
  $dbs = wmf_civicrm_get_dbs();
  $dbs->push('civicrm');

  db_query("ALTER TABLE civicrm_contact
            MODIFY preferred_language varchar(32) DEFAULT NULL");
}

/**
 * Create recurring restarted contribution tag
 */
function wmf_civicrm_update_7016() {
  $ret = array();
  $api = wmf_civicrm_bootstrap_civi();
  wmf_civicrm_create_option_values_detailed('tag_used_for', array(
    'Contributions' => array('value' => 'civicrm_contribution'),
  ));

  $success = $api->Tag->get(array(
    'name' => 'RecurringRestarted',
    'used_for' => 'civicrm_contribution',
  ));
  if (!count($api->values)) {
    $success = $api->Tag->create(array(
      'name' => 'RecurringRestarted',
      'description' => 'For the first contribution of a restarted recurring subscription.',
      'is_selectable' => FALSE,
      'is_reserved' => TRUE,
      'used_for' => 'civicrm_contribution',
    ));
    if (!$success) {
      throw new DrupalUpdateException($api->errorMsg());
    }
  }
}

/**
 * Create truncated address tag
 */
function wmf_civicrm_update_7017() {
  $ret = array();
  $api = wmf_civicrm_bootstrap_civi();
  $success = $api->Tag->get(array(
    'name' => 'AddressTruncated',
    'used_for' => 'civicrm_contact',
  ));
  if (!count($api->values)) {
    $success = $api->Tag->create(array(
      'name' => 'AddressTruncated',
      'description' => 'Tag applied to a contact when the address was truncated on import.',
      'is_selectable' => TRUE,
      'is_reserved' => TRUE,
      'used_for' => 'civicrm_contact',
    ));
    if (!$success) {
      throw new DrupalUpdateException($api->errorMsg());
    }
  }
}

/**
 * Create UnrecordedCharge contribution tag
 */
function wmf_civicrm_update_7021() {
  $ret = array();
  $api = wmf_civicrm_bootstrap_civi();
  $success = $api->Tag->get(array(
    'name' => 'UnrecordedCharge',
    'used_for' => 'civicrm_contribution',
  ));
  if (!count($api->values)) {
    $success = $api->Tag->create(array(
      'name' => 'UnrecordedCharge',
      'description' => 'For donations which have already been charged, but were not recorded in Civi at the time.',
      'is_selectable' => FALSE,
      'is_reserved' => TRUE,
      'used_for' => 'civicrm_contribution',
    ));
    if (!$success) {
      throw new DrupalUpdateException($api->errorMsg());
    }
  }
}

/**
 * DO NOT RUN ON PRODUCTION Add gift data group.
 */
function wmf_civicrm_update_7022() {
  $api = wmf_civicrm_bootstrap_civi();
  $success = $api->CustomGroup->get(array(
    'name' => 'Gift_Data',
  ));
  if (!$success || !count($api->values)) {
    $success = $api->CustomGroup->create(array(
      'extends' => 'Contribution',
      'name' => 'Gift_Data',
      'title' => ts('Gift Data'),
      'is_active' => 1,
    ));
    if (!$success) {
      throw new DrupalUpdateException($api->errorMsg());
    }
  }
  $custom_group_id = $api->values[0]->id;

  $success = $api->CustomField->create(array(
    'custom_group_id' => $custom_group_id,
    'name' => 'Fund',
    'column_name' => 'fund',
    'label' => ts('Restrictions'),
    'data_type' => 'String',
    'html_type' => 'Select',
    'default_value' => 'Unrestricted - General',
    'is_active' => 1,
    'is_required' => 1,
    'is_searchable' => 1,
  ));
  if (!$success) {
    throw new DrupalUpdateException($api->errorMsg());
  }

  $success = $api->CustomField->create(array(
    'custom_group_id' => $custom_group_id,
    'name' => 'Campaign',
    'column_name' => 'campaign',
    'label' => ts('Gift Source'),
    'data_type' => 'String',
    'html_type' => 'Select',
    'default_value' => 'Community Gift',
    'is_active' => 1,
    'is_required' => 1,
    'is_searchable' => 1,
  ));
  if (!$success) {
    throw new DrupalUpdateException($api->errorMsg());
  }

  $success = $api->CustomField->create(array(
    'custom_group_id' => $custom_group_id,
    'name' => 'Appeal',
    'column_name' => 'appeal',
    'label' => ts('Direct Mail Appeal'),
    'data_type' => 'String',
    'html_type' => 'Select',
    'default_value' => 'spontaneousdonation',
    'is_active' => 1,
    'is_required' => 1,
    'is_searchable' => 1,
  ));
  if (!$success) {
    throw new DrupalUpdateException($api->errorMsg());
  }

  // TODO: define option groups in another migration if necessary
}

/**
 * Add custom donor data group.
 */
function wmf_civicrm_update_7023() {
  $api = wmf_civicrm_bootstrap_civi();
  $api->CustomGroup->get(array(
    'name' => 'WMF_Donor',
  ));
  $result = $api->values();
  if ($result) {
    return;
  }

  $success = $api->CustomGroup->create(array(
    'extends' => 'Contact',
    'name' => 'wmf_donor',
    'table_name' => 'wmf_donor',
    'title' => ts('WMF Donor'),
    'is_active' => 1,
  ));
  if (!$success) {
    throw new DrupalUpdateException('Could not create custom group');
  }
  $values = $api->values();
  $custom_group = array_pop($values);

  $success = $api->CustomField->create(array(
    'custom_group_id' => $custom_group->id,
    'name' => 'do_not_solicit',
    'column_name' => 'do_not_solicit',
    'label' => ts('Do not solicit'),
    'data_type' => 'Boolean',
    'html_type' => 'Radio',
    'is_active' => 1,
    'is_required' => 1,
    'is_searchable' => 1,
  ));
  if (!$success) {
    throw new DrupalUpdateException('Failed to create custom field.');
  }
}

/**
 * Add yearly contribution rollup and last donation data
 */
function wmf_civicrm_update_7024() {
  $api = wmf_civicrm_bootstrap_civi();
  $api->CustomGroup->get(array(
    'name' => 'wmf_donor',
  ));
  $result = $api->values();
  if (!$result) {
    throw new DrupalUpdateException('Could not find custom group wmf_donor.  Please run update 7023 first.');
  }

  $custom_group = array_pop($result);

  for ($year = WMF_MIN_ROLLUP_YEAR; $year <= WMF_MAX_ROLLUP_YEAR; $year++) {
    $nextYear = $year + 1;
    $success = $api->CustomField->create(array(
      'custom_group_id' => $custom_group->id,
      'name' => "is_{$year}_donor",
      'column_name' => "is_{$year}_donor",
      'label' => ts("Is FY {$year}-{$nextYear} donor"),
      'data_type' => 'Boolean',
      'html_type' => 'Radio',
      'default_value' => 0,
      'is_active' => 1,
      'is_required' => 0,
      'is_searchable' => 1,
      'is_view' => 1,
    ));
    if (!$success) {
      throw new DrupalUpdateException($api->errorMsg());
    }
  }
  $success = $api->CustomField->create(array(
    'custom_group_id' => $custom_group->id,
    'name' => 'last_donation_date',
    'column_name' => 'last_donation_date',
    'label' => ts('Last donation date'),
    'data_type' => 'Date',
    'html_type' => 'Select Date',
    'is_active' => 1,
    'is_searchable' => 1,
    'is_search_range' => 1,
    'is_view' => 1,
    'date_format' => 'M d, yy',
    'time_format' => 2,
  ));
  if (!$success) {
    throw new DrupalUpdateException($api->errorMsg());
  }

  $success = $api->CustomField->create(array(
    'custom_group_id' => $custom_group->id,
    'name' => 'last_donation_currency',
    'column_name' => 'last_donation_currency',
    'label' => ts('Last Donation Currency'),
    'data_type' => 'String',
    'html_type' => 'Text',
    'is_active' => 1,
    'is_searchable' => 1,
    'is_view' => 1,
  ));
  if (!$success) {
    throw new DrupalUpdateException($api->errorMsg());
  }

  $success = $api->CustomField->create(array(
    'custom_group_id' => $custom_group->id,
    'name' => 'last_donation_amount',
    'column_name' => 'last_donation_amount',
    'label' => ts('Last Donation Amount (unconverted)'),
    'data_type' => 'Money',
    'html_type' => 'Text',
    'is_active' => 1,
    'is_searchable' => 1,
    'is_search_range' => 1,
    'is_view' => 1,
  ));
  if (!$success) {
    throw new DrupalUpdateException($api->errorMsg());
  }

  $success = $api->CustomField->create(array(
    'custom_group_id' => $custom_group->id,
    'name' => 'last_donation_usd',
    'column_name' => 'last_donation_usd',
    'label' => ts('Last Donation Amount (USD)'),
    'data_type' => 'Money',
    'html_type' => 'Text',
    'is_active' => 1,
    'is_searchable' => 1,
    'is_search_range' => 1,
    'is_view' => 1,
  ));
  if (!$success) {
    throw new DrupalUpdateException($api->errorMsg());
  }

  $success = $api->CustomField->create(array(
    'custom_group_id' => $custom_group->id,
    'name' => 'lifetime_usd_total',
    'column_name' => 'lifetime_usd_total',
    'label' => ts('Lifetime Donations (USD)'),
    'data_type' => 'Money',
    'html_type' => 'Text',
    'is_active' => 1,
    'is_searchable' => 1,
    'is_search_range' => 1,
    'is_view' => 1,
  ));
  if (!$success) {
    throw new DrupalUpdateException($api->errorMsg());
  }
}

/**
 * Add indexes to the civicrm_prevnext_cache table.
 *
 * In CiviCRM 4.6 these are in core.
 */
function wmf_civicrm_update_7025() {

}

/**
 * Fix year rollup HTML type
 */
function wmf_civicrm_update_7027() {
  $api = wmf_civicrm_bootstrap_civi();
  $api->CustomGroup->get(array(
    'name' => 'wmf_donor',
  ));
  $result = $api->values();
  if (!$result) {
    throw new DrupalUpdateException('Could not find custom group wmf_donor.  Please run update 7023 first.');
  }

  $custom_group = array_pop($result);

  $dbs = wmf_civicrm_get_dbs();
  $dbs->push('civicrm');

  db_query("UPDATE civicrm_custom_field
        SET html_type = 'Radio'
        WHERE custom_group_id = {$custom_group->id}
        AND column_name LIKE 'is%donor'
        AND html_type = 'CheckBox'");
}

/**
 * Add "Engage" contribution type
 *
 * Note that we create the "Engage Direct Mail" role programatically, but it
 * won't have usable permissions.
 */
function wmf_civicrm_update_7028() {
  if (FALSE === user_role_load_by_name('Engage Direct Mail')) {
    $role = new stdClass();
    $role->name = 'Engage Direct Mail';
    user_role_save($role);
  }

  wmf_civicrm_bootstrap_civi();
  wmf_civicrm_create_financial_types(array(
    'Engage',
  ));
}

/**
 * Rename "Old and add "Old 2015" Location Type values
 *
 * We are also adding existing values programmatically if they don't already
 * exist.
 */
function wmf_civicrm_update_7029() {
  $api = wmf_civicrm_bootstrap_civi();
  $location_types = array(
    'Home' => 'Home',
    'Work' => 'Work',
    'Main' => 'Main',
    'Other' => 'Other',
    'Mailing' => 'Mailing',
    'Billing' => 'Billing',
    'Old' => 'Old 2014',
    'Old_2015' => 'Old 2015',
  );
  wmf_civicrm_create_location_types($location_types, TRUE);
}

/**
 * Add some custom fields that already exist on production
 */
function wmf_civicrm_update_7030() {
  $warnings = array();

  $api = wmf_civicrm_bootstrap_civi();
  $success = $api->CustomGroup->get(array(
    'name' => 'Organization_Contact',
  ));
  if (!$success || !$api->count) {
    $success = $api->CustomGroup->create(array(
      'name' => 'Organization_Contact',
      'title' => 'Organization Contact',
      'extends' => 'Organization',
      'is_active' => 1,
    ));
    if (!$success) {
      throw new DrupalUpdateException($api->errorMsg());
    }
  }
  $custom_group_id = $api->id;

  $success = $api->CustomField->create(array(
    'custom_group_id' => $custom_group_id,
    'name' => 'Name',
    'label' => ts('Name'),
    'data_type' => 'String',
    'html_type' => 'Text',
    'is_active' => 1,
    'is_required' => 0,
    'is_searchable' => 1,
    'is_view' => 0,
  ));
  if (!$success) {
    $warnings[] = $api->errorMsg();
  }

  $success = $api->CustomField->create(array(
    'custom_group_id' => $custom_group_id,
    'name' => 'Title',
    'label' => ts('Title'),
    'data_type' => 'String',
    'html_type' => 'Text',
    'is_active' => 1,
    'is_required' => 0,
    'is_searchable' => 0,
    'is_view' => 0,
  ));
  if (!$success) {
    $warnings[] = $api->errorMsg();
  }

  return implode("\n", $warnings);
}

/**
 * Add more custom fields that already exist on production
 */
function wmf_civicrm_update_7031() {

  $api = wmf_civicrm_bootstrap_civi();
  $financialTypes = wmf_civicrm_create_financial_types(array('Stock'));
  $stockContributionTypeId = array_search('Stock', $financialTypes);

  $success = $api->CustomGroup->get(array(
    'name' => 'Stock_Information',
  ));
  if (!$success || !$api->count) {
    $success = $api->CustomGroup->Create(array(
      'name' => 'Stock_Information',
      'title' => 'Stock Information',
      'extends' => 'Contribution',
      'extends_entity_column_value' => array($stockContributionTypeId),
      'is_active' => 1,
    ));
    if (!$success) {
      throw new DrupalUpdateException($api->errorMsg());
    }
  }
  $custom_group = $api->values[0];

  $success = $api->CustomField->Create(array(
    'custom_group_id' => $custom_group->id,
    'data_type' => 'String',
    'html_type' => 'Text',
    'is_active' => 1,
    'is_searchable' => 1,
    'label' => 'Description of Stock',
    'name' => 'Description_of_Stock',
  ));
  if (!$success) {
    throw new DrupalUpdateException($api->errorMsg());
  }
}

/**
 * Link Restrictions, Gift Source, Appeal options to custom fields.
 */
function wmf_civicrm_update_7032() {

  _link_gift_data_field_to_new_group('Fund', 'fund_20080709173248', array(
    'Unrestricted - General',
    'Restricted - Foundation',
    'Restricted - Program',
    'Restricted - Fiscal Sponsorship',
  ));

  _link_gift_data_field_to_new_group('Campaign', 'campaign_20080709183311', array(
    'Community Gift',
    'Benefactor Gift',
    'Foundation Gift',
    'Matching Gift',
    'Donor Advised Fund',
    'Corporate Gift',
    'Legacy Gift',
    'Chapter Gift',
    'Major Gift',
    'Combined Federal Campaign',
    'Payroll Deduction',
  ));

  _link_gift_data_field_to_new_group('Appeal', 'appeal_20080709183729', array(
    'White Mail',
    'Spontaneous Donation',
    'Facebook',
    'Event',
    'Mobile Giving',
    'Corp Matching Gift',
  ));
}

/**
 * Add option value 'tag_used_for' for civicrm_contribution.
 *
 * This might exist as it had to be added to update 7016 so check first.d
 *
 * Note I have skipped to 7060 leaving a numerical gap for upgrades that happen
 * in master before this is merged.
 */
function wmf_civicrm_update_7060() {
  wmf_civicrm_bootstrap_civi();
  wmf_civicrm_create_option_values_detailed('tag_used_for', array(
    'Contributions' => array('value' => 'civicrm_contribution'),
  ));
}

/**
 * Append '&output=context' to all report instances.
 *
 * This 'upgrades' existing reports to not render results when opened by
 * default.
 *
 * Although the GR work changed the default this isn't going to fly upstream so
 * we need to change the behaviour of all of the WMF reports in a way that
 * won't be later reverted so adding a parameter & upstreaming the meaning of
 * that parameter provides future proofing.
 *
 * CRM-17225
 */
function wmf_civicrm_update_7061() {
  $dbs = wmf_civicrm_get_dbs();
  $dbs->push('civicrm');
  db_query(
    "UPDATE civicrm_navigation
    SET url = CONCAT(url, '&output=criteria')
    WHERE url LIKE 'civicrm\/report\/instance%'
    AND url NOT LIKE '%output=criteria%'"
  );
}

/**
 * Set default language for contacts to 'undefined'.
 *
 * This means a new contact created will have an empty language rather than a
 * guessed one.
 *
 * CRM-14232
 *
 * @throws \CiviCRM_API3_Exception
 */
function wmf_civicrm_update_7062() {
  civicrm_initialize();
  civicrm_api3('Setting', 'create', array(
    'contact_default_language' => "undefined",
  ));
}

/**
 * Reset navigation menu.
 *
 * CRM-17176
 *
 * @throws \CiviCRM_API3_Exception
 */
function wmf_civicrm_update_7063() {
  civicrm_initialize();
  civicrm_api3('Navigation', 'reset', array(
    'for' => "report",
  ));
}

/**
 * Add appeal data that has been missed.
 *
 * Note there was a change in early Nov that stopped these from coming in.
 *
 * This update goes back 'a bit further' but is a somewhat arbitrary date.
 *
 * T121284
 */
function wmf_civicrm_update_7064() {
  wmf_civicrm_fill_missing_appeal_data('2015-10-01');
}

/**
 * Ensure all payments have a payment instrument id.
 *
 * Per
 * http://wiki.civicrm.org/confluence/display/CRMDOC/Fixing+Transactions+Missing+a+Payment+Instrument+-+4.4.3+Upgrades
 * there is a payment instrument id set for all contributions.
 *
 * The code there basically just figures out a default & sets the empty ones to
 * that.
 *
 * If we look at the first million contributions just setting the it to
 * 'Gateway' seems a reasonable choice of default.
 *
 * SELECT  payment_instrument_id, count(*) FROM (SELECT * FROM
 * civicrm_contribution LIMIT 1000000) as t GROUP BY payment_instrument_id;
 * +-----------------------+----------+
 * | payment_instrument_id | count(*) |
 * +-----------------------+----------+
 * |                  NULL |       33 |
 * |                     1 |        3 |
 * |                     3 |       30 |
 * |                     4 |    14162 |
 * |                     5 |      119 |
 * |                     6 |   982954 |
 * |                     7 |     1451 |
 * |                     8 |     1246 |
 * |                    44 |        1 |
 * |                   186 |        1 |
 */
function wmf_civicrm_update_7065() {
  civicrm_initialize();
  // Ensure that 'Gateway' option exists. Will be a no-op if it's already there.
  wmf_civicrm_create_option_values('payment_instrument', array('Gateway'));
  $paymentInstruments = civicrm_api3('Contribution', 'getoptions', array('field' => 'payment_instrument_id'));
  $defaultPaymentInstrument = array_search('Gateway', $paymentInstruments['values']);
  CRM_Core_DAO::executeQuery(
    "UPDATE civicrm_contribution SET payment_instrument_id = $defaultPaymentInstrument WHERE payment_instrument_id IS NULL"
  );
  CRM_Core_DAO::executeQuery(
    "UPDATE civicrm_financial_trxn cft
LEFT JOIN civicrm_entity_financial_trxn ceft ON ceft.financial_trxn_id = cft.id
LEFT JOIN civicrm_contribution cc  ON ceft.entity_id = cc.id
SET cft.payment_instrument_id = IFNULL(cc.payment_instrument_id, $defaultPaymentInstrument)
WHERE ceft.entity_table = 'civicrm_contribution' AND cft.payment_instrument_id IS NULL;"
  );
}

/**
 * Update upgraded 4.2 refund transactions to have negative refund records.
 *
 * In the 4.3 upgrade transaction records were done for statuses Completed
 * Pending and Cancelled. The status Refunded was not a core status until 4.3
 * so transactions were NOT added in the upgrade to refunded status
 * transactions.
 *
 * The original upgrade code is in the function
 * CRM_Upgrade_Incremental_php_FourThree::createFinancialRecords
 *
 * I tried re-editing it for use here but the sql was just too slow and we
 * don't
 * want another long-outage. It's probably slower for this section than on the
 * main upgrade as the financial_trxn table has been populated in the meantime.
 * The main upgrade sql included adding and dropping columns on tables whereas
 * here I have used LAST_INSERT_ID() to get the inserted row ids.
 *
 * OTOH we only need to deal with ~16k records to php parsing is a reasonable
 * option
 * (it might take a little while but it won't lock the tables so I don't think
 * the site would need to come down to run it).
 */
function wmf_civicrm_update_7070() {
  require_once('update_7070.php');
  _wmf_civicrm_update_7070_fill_refund_transaction_data();
}

/**
 * Remove any duplication of the 'Refunded' Contribution status.
 *
 * This status was added to WMF & then added to core - resulting in
 * 2 on WMF. The retained one should be set to reserved.
 *
 * NB I didn't add this to the install as I don't think it should be relevant
 * there.
 *
 * T116317
 *
 * @throws \CiviCRM_API3_Exception
 */
function wmf_civicrm_update_7075() {
  civicrm_initialize();
  if ((civicrm_api3('OptionValue', 'getcount', array(
      'name' => 'Refunded',
      'option_group_id' => 'contribution_status',
    ))) == 1) {
    // Nothing to do here, move along.
    return;
  }
  $options = civicrm_api3('OptionValue', 'get', array(
    'name' => 'Refunded',
    'option_group_id' =>
      'contribution_status',
    'sequential' => 1,
    'options' => array('sort' => 'id ASC'),
  ));

  if ($options['count'] != 2) {
    throw new Exception(ts('This is an unexpected state - we are only expecting to handle the situation where there is one wmf added & one core added. Please wave a wand'));
  }

  $expectedRedundantType = $options['values'][1];
  $refundValueToKeep = $options['values'][0]['value'];

  if (civicrm_api3('Contribution', 'getcount', array('contribution_status_id' => $expectedRedundantType['value']))) {
    CRM_Core_DAO::executeQuery("DELETE FROM civicrm_financial_trxn WHERE status_id = %1", array(
      1 => array(
        $expectedRedundantType['value'],
        'Integer',
      ),
    ));
    CRM_Core_DAO::executeQuery("UPDATE civicrm_contribution SET contribution_status_id = %1 WHERE contribution_status_id = %2", array(
      1 => array($refundValueToKeep, 'Integer'),
      2 => array($expectedRedundantType['value'], 'Integer'),
    ));
  }
  civicrm_api3('OptionValue', 'delete', array('id' => $expectedRedundantType['id']));
  civicrm_api3('OptionValue', 'create', array(
    'id' => $options['values'][0]['id'],
    'is_reserved' => TRUE,
  ));
}

/**
 * Add indexes that are missing from CiviCRM 4.6.
 *
 * These indexes have been added to 4.7 using the same php function.
 *
 * This function checks the index does not already exist before adding it.
 * This ensures that we will not hit a problem on upgrade as a result of adding
 * them now.
 *
 * Note this could be a slow update.
 *
 * https://github.com/civicrm/civicrm-core/pull/7672
 * https://github.com/civicrm/civicrm-core/pull/7678
 * https://github.com/civicrm/civicrm-core/pull/7673
 */
function wmf_civicrm_update_7080() {
  civicrm_initialize();
  $tables = array('civicrm_contribution' => array('creditnote_id'));
  CRM_Core_BAO_SchemaHandler::createIndexes($tables);

  $tables = array('civicrm_financial_trxn' => array('trxn_id'));
  CRM_Core_BAO_SchemaHandler::createIndexes($tables);
}

/**
 * T122947 add index to civicrm_financial item.
 *
 * The existing one does not start with entity_id so the queries that omit
 * entity_table dont' use it. It is also logically the wrong way around as the
 * one with more variation should lead.
 *
 * The upstream patch (CRM-17775) removes indexes as well. I have not ported
 * that part back at this stage as I'm viewing it as tidy up rather than a
 * performance fix and leaving 4.7.2 upgrade to catch it.
 */
function wmf_civicrm_update_7090() {
  civicrm_initialize();
  CRM_Core_BAO_SchemaHandler::createIndexes(array(
    'civicrm_financial_item' => array(array('entity_id', 'entity_table')),
  ));
}

/**
 * T124979 add Chargeback refund status and chargeback & contra account
 * relationships.
 *
 * This is the same code in 4.7.2 to add these options and is written to be
 * upgrade safe.
 */
function wmf_civicrm_update_7100() {
  civicrm_initialize();
  // First we enable and edit the record for Credit contra - this exists but is disabled for most sites.
  // Using the ensure function (below) will not enabled a disabled option (by design).
  CRM_Core_DAO::executeQuery("UPDATE civicrm_option_value v
     INNER JOIN civicrm_option_group g on v.option_group_id=g.id and g.name='account_relationship'
     SET v.is_active=1, v.label='Credit/Contra Revenue Account is', v.name='Credit/Contra Revenue Account is', v.description='Credit/Contra Revenue Account is'
     WHERE v.name = 'Credit/Contra Account is';");
  CRM_Core_BAO_OptionValue::ensureOptionValueExists(array(
    'option_group_id' => 'account_relationship',
    'name' => 'Chargeback Account is',
    'label' => ts('Chargeback Account is'),
    'is_active' => TRUE,
    'component_id' => 'CiviContribute',
  ));
  CRM_Core_BAO_OptionValue::ensureOptionValueExists(array(
    'option_group_id' => 'contribution_status',
    'name' => 'Chargeback',
    'label' => ts('Chargeback'),
    'is_active' => TRUE,
    'component_id' => 'CiviContribute',
  ));
}

/**
 * 123418 / CRM-17999 add index to civicrm_contribution.source field.
 */
function wmf_civicrm_update_7110() {
  civicrm_initialize();
  CRM_Core_BAO_SchemaHandler::createIndexes(array('civicrm_contribution' => array('source')));
}

/**
 * T124979 add a Financial Account to each Financial Type for Chargeback &
 * Refund.
 */
function wmf_civicrm_update_7120() {
  civicrm_initialize();
  $financialTypes = civicrm_api3('FinancialType', 'get', array());

  foreach (array_keys($financialTypes['values']) as $financialTypeID) {
    civicrm_api3('EntityFinancialAccount', 'create', array(
      'entity_id' => $financialTypeID,
      'entity_table' => 'civicrm_financial_type',
      'account_relationship' => 'Chargeback Account is',
      'financial_account_id' => 'Chargeback',
    ));
    civicrm_api3('EntityFinancialAccount', 'create', array(
      'entity_id' => $financialTypeID,
      'entity_table' => 'civicrm_financial_type',
      'account_relationship' => 'Credit/Contra Revenue Account is',
      'financial_account_id' => 'Refund',
    ));
  }
}

/**
 * T122946 fix financial trxn record for upgraded contributions missing
 * to_financial_account_id.
 *
 * These came about in the upgrade (this update does not need to run on
 * install) and affect the same contributions as update 7065.
 *
 * My queries suggest they all have financial_type = 'Cash' so I explicitly
 * limited to that.
 */
function wmf_civicrm_update_7130() {
  civicrm_initialize();
  $depositFinancialAccountID = civicrm_api3('FinancialAccount', 'getvalue', array(
    'return' => 'id',
    'name' => 'Deposit Bank Account',
  ));

  $cashFinancialTypeID = civicrm_api3('FinancialType', 'getvalue', array(
    'return' => 'id',
    'name' => 'Cash',
  ));
  CRM_Core_DAO::executeQuery(
    "UPDATE
     civicrm_contribution con
     LEFT JOIN civicrm_entity_financial_trxn eft ON (eft.entity_id = con.id AND eft.entity_table = 'civicrm_contribution')
     INNER JOIN civicrm_financial_trxn ft ON ft.id = eft.financial_trxn_id

     SET ft.to_financial_account_id = %1

     WHERE ft.to_financial_account_id IS NULL AND con.financial_type_id = %2",
    array(
      1 => array($depositFinancialAccountID, 'Integer'),
      2 => array($cashFinancialTypeID, 'Integer'),
    )
  );
}

/**
 * T126543 adjust donor field labels to indicate they are fiscal year.
 *
 * 'Is 2016 Donor' actually means 'Is FY 2016-2017 Donor'
 */
function wmf_civicrm_update_7141() {
  civicrm_initialize();
  $fields = civicrm_api3('CustomField', 'get', array('custom_group_id' => 'wmf_donor'));
  foreach ($fields['values'] as $field) {
    $fieldNameParts = explode('_', $field['name']);
    if ($fieldNameParts[0] == 'is' && $fieldNameParts[2] == 'donor') {
      civicrm_api3('CustomField', 'create', array(
        'id' => $field['id'],
        'label' => 'Is FY ' . $fieldNameParts[1] . '-' . ($fieldNameParts[1] + 1) . ' donor',
      ));
    }
  }
}

/**
 * Fix financial item records with null financial_account.
 *
 * Incredibly we have only 4 of these in our database & Elliott picked up this
 * problem through spot checks!.
 *
 * Reference contact is civicrm/contact/view?reset=1&cid=11346599 - before this
 * update one of the contact's transactions does not display financial details
 * when expanded in the UI.
 *
 *  [civicrm]> SELECT count(*) FROM civicrm_financial_item WHERE
 * financial_account_id IS NULL;
 * +----------+
 * | count(*) |
 * +----------+
 * |        4 |
 * +----------+
 *
 * These relate to line items with no financial_type_id of which we have 74.
 *
 * SELECT count(*) FROM civicrm_line_item li LEFT JOIN civicrm_contribution c
 * ON c.id = li.contribution_id WHERE li.financial_type_id IS NULL;
 * +----------+
 * | count(*) |
 * +----------+
 * |       74 |
 * +----------+
 *
 * Of those 74 rows 70 are orphans - ie line items with no contributions. It
 * appears the contributions were deleted at some point in the past.
 *
 * This relates to T122946 & is a follow up fix.
 */
function wmf_civicrm_update_7150() {
  civicrm_initialize();
  $cashFinancialTypeID = civicrm_api3('FinancialType', 'getvalue', array(
    'return' => 'id',
    'name' => 'Cash',
  ));

  $cashFinancialAccountID = civicrm_api3('FinancialAccount', 'getvalue', array(
    'return' => 'id',
    'name' => 'Cash',
  ));
  // Deletes 70 orphan entries - a bit slow but I couldn't bring myself to take out the join & just filter
  // on contribution_id IS NOT NULL as it felt less safe. Takes 1-2 minutes
  CRM_Core_DAO::executeQuery("
    DELETE li
    FROM civicrm_line_item li
    LEFT JOIN civicrm_contribution c ON li.entity_id = c.id
    AND li.entity_table = 'civicrm_contribution'
    WHERE c.id IS NULL
  ");
  // Updates 4 records.
  CRM_Core_DAO::executeQuery("UPDATE civicrm_contribution SET financial_type_id = $cashFinancialTypeID WHERE financial_type_id IS NULL");
  // Updates 4 records.
  CRM_Core_DAO::executeQuery("UPDATE civicrm_line_item SET financial_type_id = $cashFinancialTypeID WHERE financial_type_id IS NULL");
  // Updates 4 records.
  CRM_Core_DAO::executeQuery("UPDATE civicrm_financial_item SET financial_account_id = $cashFinancialAccountID WHERE financial_account_id IS NULL");

}

/**
 * Further refund financial data fix.
 *
 * This is an extra record that was missing in 7070. It was obvious until the
 * patch for CRM-17951 was merged:
 *
 * CRM-17951 (merged into 4.7) modify transaction view to show the financial
 * account of the transaction
 */
function wmf_civicrm_update_7160() {
  civicrm_initialize();
  CRM_Core_DAO::executeQuery("
    INSERT INTO civicrm_entity_financial_trxn
    (entity_table, entity_id, financial_trxn_id, amount)
    SELECT  'civicrm_financial_item' as entity_table, fi.id as entity_id, cont_ft.financial_trxn_id  as financial_trxn_id, fi.amount
    FROM civicrm_financial_item fi
    LEFT JOIN civicrm_entity_financial_trxn ft  ON ft.entity_id = fi.id AND ft.entity_table = 'civicrm_financial_item'
    LEFT JOIN civicrm_line_item li ON li.id = fi.entity_id AND fi.entity_table = 'civicrm_line_item'
    LEFT JOIN civicrm_contribution c ON c.id = li.contribution_id
    LEFT JOIN civicrm_entity_financial_trxn cont_ft ON cont_ft.entity_id = c.id AND cont_ft.entity_table = 'civicrm_contribution'
    WHERE ft.id IS NULL AND fi.created_date > '2016-02-01'
  ");
}

/**
 * Further refund financial data fix.
 *
 * This is a change Elliott made on live to reflect these accounts as Expenses
 * not Income.
 *
 * Added here to ensure dev sites have the same info.
 */
function wmf_civicrm_update_7170() {
  civicrm_initialize();
  CRM_Core_DAO::executeQuery("
   UPDATE civicrm_financial_account
   SET account_type_code = 'EXP',
   financial_account_type_id = (
     SELECT v.value
     FROM civicrm_option_value v
     INNER JOIN civicrm_option_group g
       ON g.id = v.option_group_id AND g.name = 'financial_account_type'
       AND v.name = 'Expenses'
   )
   WHERE name in ('Refund', 'Chargeback')
  ");
}

/**
 * Fix e-Notice due to some Option Values not having the 'name' field filled in.
 *
 * This is just an e-notice visible in the jenkins log. It appears to do no harm
 * other than having caused me to investigate it when checking the logs.
 *
 * T127029.
 */
function wmf_civicrm_update_7180() {
  civicrm_initialize();
  CRM_Core_DAO::executeQuery("
    UPDATE civicrm_option_group g
    LEFT JOIN civicrm_option_value v ON v.option_group_id = g.id
    INNER JOIN civicrm_custom_field cf ON cf.option_group_id = g.id
    SET v.name = REPLACE(v.value, ' ', '_')
    WHERE
     v.name IS NULL
  ");
}

/**
 * T128221 add index to civicrm_contribution.total_amount.
 *
 * Note that I made this a combined index with receive_date because the ticket
 * included both criteria and they seemed likely to be used in conjunction to
 * me in other cases.
 *
 * I ran the offending search on staging afterwards and it was fast.
 */
function wmf_civicrm_update_7190() {
  civicrm_initialize();
  CRM_Core_BAO_SchemaHandler::createIndexes(array(
    'civicrm_contribution' => array(array('total_amount', 'receive_date')),
  ));
}

/**
 * Add contact deleted by merge activity.
 *
 * CRM-18106 / T119246.
 */
function wmf_civicrm_update_7200() {
  civicrm_initialize();
  CRM_Core_BAO_OptionValue::ensureOptionValueExists(array(
    'option_group_id' => 'activity_type',
    'name' => 'Contact Deleted by Merge',
    'label' => ts('Contact Deleted by Merge'),
    'description' => ts('Contact was merged into another contact'),
    'is_active' => TRUE,
    'filter' => 1,
  ));
}

/**
 * Enable setting to specify logging is handled offline.
 *
 * CRM-18212 / T127133.
 */
function wmf_civicrm_update_7205() {
  civicrm_initialize();
  civicrm_api3('System', 'flush', array(
    'triggers' => 0,
    'session' => 0,
  ));
  civicrm_api3('Setting', 'create', array(
    'logging_no_trigger_permission' => 1,
  ));
}

/**
 * Oops this activity type was added without filter = 1 being set.
 *
 * CRM-18327 / T119246.
 */
function wmf_civicrm_update_7210() {
  civicrm_initialize();
  CRM_Core_DAO::executeQuery(
    "UPDATE civicrm_option_value ov
       LEFT JOIN civicrm_option_group og ON og.id = ov.option_group_id
       SET filter = 1
       WHERE ov.name = 'Contact Deleted By Merge' AND og.name = 'activity_type'"
  );
}

/**
 * Create additional prospecting custom fields.
 */
function wmf_civicrm_update_7220() {
  require_once 'update_custom_fields.php';
  _wmf_civicrm_update_custom_fields();
}

/**
 * Set do not trade field to 0 for all contacts.
 *
 * We do not use this field.
 */
function wmf_civicrm_update_7225() {
  civicrm_initialize();
  CRM_Core_DAO::executeQuery(
    "UPDATE civicrm_contact SET do_not_trade = 0"
  );
}

/**
 * Add Endowment gifts to gift source.
 *
 * T139629
 */
function wmf_civicrm_update_7230() {
  civicrm_initialize();
  CRM_Core_BAO_OptionValue::ensureOptionValueExists(array(
    'name' => 'Endowment Gift',
    'value' => 'Endowment Gift',
    'option_group_id' => 'campaign_20080709183311',
  ));
}

/**
 * Add Endowment gift to financial type.
 *
 * T139629
 */
function wmf_civicrm_update_7235() {
  civicrm_initialize();
  wmf_civicrm_create_financial_types(array(
    'Endowment Gift',
  ));
}

/**
 * Fix next_sched_contribution_date on records affected by Aug recur bug.
 *
 * There appear to be only 8 that still need fixing before re-enabling the job.
 *
 * These 8 failed to re-process on their second attempt so were not reset.
 *
 * The others all re-processed within the affected time period and their dates
 * were pushed out
 *
 * SQL to view these 8.
 *
 * SELECT count(*) as c, contribution_recur_id, cr.contact_id,
 * group_concat(receive_date) as rdate, next_sched_contribution_date,
 * c.contribution_status_id, cr.contribution_status_id FROM
 * civicrm_contribution c LEFT JOIN civicrm_contribution_recur cr ON cr.id =
 * c.contribution_recur_id WHERE receive_date > '2016-08-31' AND
 * contribution_recur_id IS NOT NULL AND c.trxn_id LIKE 'RECURRING
 * GLOBALCOLLECT%' AND next_sched_contribution_date < '2016-09-30' GROUP BY
 * contribution_recur_id having c = 1 AND rdate < '2016-09-01';
 *
 * To view the others:
 *
 * SELECT count(*) as c, contribution_recur_id, c.contact_id,
 * group_concat(receive_date) as dates, next_sched_contribution_date,
 * GROUP_CONCAT(c.trxn_id) FROM civicrm_contribution c Left JOIN
 * civicrm_contribution_recur cr ON cr.id = c.contribution_recur_id WHERE
 * receive_date > '2016-08-30' AND contribution_recur_id IS NOT NULL AND
 * c.trxn_id LIKE 'RECURRING GLOBALCOLLECT%' GROUP BY contribution_recur_id
 * having c > 1;
 *
 * T144489
 */
function wmf_civicrm_update_7240() {
  civicrm_initialize();
  CRM_Core_DAO::executeQuery("
    UPDATE civicrm_contribution_recur
    SET
      failure_retry_date = NULL,
      failure_count = 0,
      next_sched_contribution_date = '2010-10-01',
      contribution_status_id = 5

   WHERE id IN
    (SELECT  contribution_recur_id FROM (
      SELECT count(*) as c, contribution_recur_id, cr.contact_id, group_concat(receive_date) as rdate,
      next_sched_contribution_date, c.contribution_status_id
      FROM civicrm_contribution c
      LEFT JOIN civicrm_contribution_recur cr ON cr.id = c.contribution_recur_id
      WHERE receive_date > '2016-08-31' AND contribution_recur_id IS NOT NULL AND c.trxn_id LIKE 'RECURRING GLOBALCOLLECT%'
       AND next_sched_contribution_date < '2016-09-30'
      GROUP BY contribution_recur_id having c = 1 AND rdate < '2016-09-01')
    as d )
    ");
}

/**
 * Remove placeholder email addresses.
 *
 * In the past nobody@wikimedia.org was used as a placeholder email. This is no
 * longer required and causes performance load & UI confusion on deduping.
 *
 * Bug: T143062
 */
function wmf_civicrm_update_7245() {
  civicrm_initialize();
  CRM_Core_DAO::executeQuery("DELETE FROM civicrm_email WHERE email = 'nobody@wikimedia.org'");
}

/**
 * Fix contacts who have no primary - this has arisen from the dedupes.
 *
 * I'll probably run this again once I've fixed dedupe to stop creating them
 * but this fixes the ~10000 contacts who currently don't have an address
 * marked as primary.
 *
 * Staging : (9 min 16.83 sec)
 *
 * Bug: T143062
 */
function wmf_civicrm_update_7250() {
  civicrm_initialize();
  CRM_Core_DAO::executeQuery("
    CREATE TEMPORARY TABLE civicrm_email_updates
     SELECT id FROM
      (
        SELECT contact_id, sum(is_primary) as c, e.id
        FROM civicrm_email e
        INNER JOIN civicrm_contact c ON c.id = contact_id AND is_deleted = 0
        GROUP BY contact_id HAVING c = 0
      ) as i
  ");

  CRM_Core_DAO::executeQuery("ALTER TABLE civicrm_email_updates ADD INDEX index_id(id)");
  CRM_Core_DAO::executeQuery("UPDATE civicrm_email e INNER JOIN civicrm_email_updates u ON e.id = u.id
    SET e.is_primary = 1
  ");
}

/**
 * T128221 add index to civicrm_contribution.total_amount.
 *
 * Bug: T96410
 */
function wmf_civicrm_update_7255() {
  civicrm_initialize();
  CRM_Core_BAO_SchemaHandler::createIndexes(array('civicrm_contact' => array('preferred_language')));
}

/**
 * Update the preferred_language field in civicrm_contact based on tracking
 * data.
 *
 * Bug: T96410
 */
function wmf_civicrm_update_7260() {
  civicrm_initialize();
  require_once('update_7260.php');
  _wmf_civicrm_update_7260_update_preferred_language();
}

/**
 * Clean up weird English variants from preferred_language field.
 *
 * Good bye Dutch English, Uzbekastani English etc.
 *
 * Bug: T96410
 */
function wmf_civicrm_update_7270() {
  civicrm_initialize();
  $nonUsefulEnglishes = array(
    // these ones have information in CldrData.php so don't alter.
    //'en_BE', 'en_ZA', 'en_BW', 'en_BZ', 'en_HK', 'en_IN', 'en_JM', 'en_NA', 'en_PK', 'en_SG', 'en_TT', 'en_ZW',
    'en_NZ', // :-(
    'en_EN', // en_GB instead? Only 3 - who cares.
    'en_SE', 'en_NO', 'en_NL', 'en_ES', 'en_IT', 'en_IL', 'en_DK', 'en_FR', 'en_IE',
    'en_MY', 'en_BR', 'en_RO', 'en_AT', 'en_HU', 'en_PL', 'en_MX', 'en_PT', 'en_JP',
    'en_CN', 'en_CZ', 'en_SK', 'en_GR', 'en_DE', 'en_AE', 'en_UA', 'en_TH', 'en_TW', 'en_LV', 'en_LU',
    'en_CH', 'en_PH', 'en_SI', 'en_BG', 'en_AR', 'en_HR', 'en_CL', 'en_CO', 'en_IS', 'en_LT', 'en_CY',
    'en_XX', 'en_KW', 'en_UY', 'en_QA', 'en_MT', 'en_PE', 'en_VN', 'en_CR', 'en_RS', 'en_LK', 'en_KZ',
    'en_EG', 'en_BH', 'en_DO', 'en_PR', 'en_NG', 'en_VE', 'en_EC', 'en_PA', 'en_OM',
    'en_BA', 'en_JO', 'en_KE', 'en_GT', 'en_MU', 'en_GE', 'en_AZ', 'en_AM', 'en_BN', 'en_MK',
    'en_NI', 'en_AL', 'en_BD', 'en_BS', 'en_BM', 'en_KH', 'en_BB', 'en_SV', 'en_MD', 'en_HN', 'en_MO',
    'en_NP', 'en_VI', 'en_MV', 'en_GI', 'en_KY', 'en_TZ', 'en_ET', 'en_AO', 'en_ME', 'en_MA',
    'en_MZ', 'en_AF', 'en_GU', 'en_PY', 'en_AD', 'en_FO', 'en_BO', 'en_MN', 'en_AW', 'en_UG',
    'en_FJ', 'en_GN', 'en_PG', 'en_GH', 'en_ZM', 'en_KG', 'en_GY', 'en_JE', 'en_CW', 'en_LC',
    'en_IM', 'en_BL', 'en_MC', 'en_SB', 'en_DZ', 'en_GL', 'en_HT', 'en_AG', 'en_GD', 'en_LA', 'en_UZ',
    'en_LI', 'en_PF', 'en_KN', 'en_DM', 'en_GG', 'en_NC', 'en_SC', 'en_GP', 'en_TC', 'en_VC', 'en_VG',
    'en_VU', 'en_PS', 'en_TN', 'en_MW', 'en_SX', 'en_SM', 'en_SR', 'en_SZ', 'en_FM', 'en_RE', 'en_RW',
    'en_SN', 'en_TJ', 'en_CM', 'en_AI', 'en_CK', 'en_LR', 'en_MG', 'en_LS', 'en_SL', 'en_TM', 'en_BJ',
    'en_MH', 'en_ML', 'en_WS', 'en_AS', 'en_BF', 'en_BQ', 'en_FK', 'en_GA', 'en_MP', 'en_MQ', 'en_CV',
    'en_GF', 'en_MF', 'en_MR', 'en_KR', 'en_NE', 'en_TL', 'en_RU', 'en_AX', 'en_BI', 'en_ID', 'en_TO',
    'en_FI', 'en_TR', 'en_SA', 'en_GM', 'en_GQ', 'en_HO', 'en_SP', 'en_AN', 'en_TA', 'en_SJ', 'en_IO',
    'en_PW', 'en_JA', 'en_CD', 'en_IR', 'en_UN', 'en_WW', 'en_CG', 'en_DJ', 'en_TD', 'en_TV', 'en_NF',
    'en_OS', 'en_DN', 'en_YE', 'en_ER', 'en_VA', 'en_BY', 'en_LB', 'en_IQ', 'en_MM', 'en_EH', 'en_LY',
    'en_BT', 'en_CF', 'en_SD', 'en_SS', 'en_KP', 'en_AQ', 'en_SH', 'en_CI', 'en_UM', 'en_WF',
    'en_KI', 'en_NU', 'en_SY', 'en_SO', 'en_TG', 'en_CU', 'en_HM', 'en_BV', 'en_MS',
  );
  CRM_Core_DAO::executeQuery("UPDATE civicrm_contact SET preferred_language = 'en' WHERE preferred_language IN('"
    . implode("', '", $nonUsefulEnglishes) . "')");
  // This only needs to run on production so hard-coding option_group_id seems OK.
  CRM_Core_DAO::executeQuery("UPDATE civicrm_option_value SET is_active = 0 WHERE option_group_id = 86 AND value IN('"
    . implode("', '", $nonUsefulEnglishes) . "')");
}

/**
 * Clean up legacy junk data from preferred_language field.
 *
 * This nulls out '_' junk data string (19690 rows)
 * and changes '_US' to 'en_US' (which is implied) (25387 rows).
 * plus some other oddities.
 *
 * Bug: T96410
 */
function wmf_civicrm_update_7275() {
  civicrm_initialize();
  // 19691 records.
  CRM_Core_DAO::executeQuery("UPDATE civicrm_contact SET preferred_language = NULL WHERE preferred_language = '_' OR preferred_language = '<c_US'");
  CRM_Core_DAO::executeQuery("UPDATE civicrm_contact SET preferred_language = 'en_US' WHERE preferred_language = '_US'");
  // There are some 14000 of these. They stopped being created 'half a database ago' and they have been
  // effectively treated as 'en' due to the fact the data is invalid. NULL has the same effect.
  // We could try to guess them by their country but that would break from what we have been doing and could be wrong.
  CRM_Core_DAO::executeQuery("UPDATE civicrm_contact SET preferred_language = NULL WHERE preferred_language LIKE '\_%'");
  // only 186, very old. Same consideration about choosing to set to NULL.
  CRM_Core_DAO::executeQuery("UPDATE civicrm_contact SET preferred_language = NULL WHERE preferred_language LIKE 'Do_%'");
  // 9356 with an extraneous '_' at the end
  CRM_Core_DAO::executeQuery("UPDATE civicrm_contact SET preferred_language = REPLACE(preferred_language, '_', '') WHERE RIGHT(preferred_language, 1) = '_'");
  // Just a single oddity.
  CRM_Core_DAO::executeQuery("UPDATE civicrm_contact SET preferred_language = 'zh_CN' WHERE preferred_language = '_CN'");
}

/**
 * Update offline message template to match thank you letter.
 *
 * The template is cut down from our standard thank you in the following ways
 *
 * 1) I pretty much by-passed translation - Im thinking this is mostly for a
 * small number of English language receipts to be manually generated. Id need
 * to do something more complex to get it translating well
 * 2) I ditched the RecurringRestarted & UnrecordedCharge logic. I figured you
 * would be sending these on request.
 * 3)I have assumed we have a first name & not done the fall-back to donor (on
 * assumption manual sends know the name).
 * 4) I did not include "{% if recurring %}<p> This donation is part of a
 * recurring subscription. Monthly payments will be debited by the Wikimedia
 * Foundation until you notify us to stop. If youd like to cancel the payments
 * please see our
 * <a
 * href="https://wikimediafoundation.org/wiki/Special:LandingCheck?landing_page=Cancel_or_change_recurring_payment..
 *
 * In other words this is a pretty-simple English language solution.
 *
 * Bug T137496
 */
function wmf_civicrm_update_7280() {
  require_once 'update_receipt.php';
  _wmf_civicrm_update_offline_receipt();
}

/**
 * Re-update the message template to fix:
 *
 *  - missing currency symbol on the second reference to the amount
 *  - not using original currency/ amount where available.
 *
 * As noted in the commit message I have reservations about the approach
 * (using smarty in the template) now that I realise the template
 * only knows the label, not the machine name of the custom fields.
 *
 * This gives an immediate win but I don't think it's over.
 *
 * BUG: T137496
 */
function wmf_civicrm_update_7285() {
  require_once 'update_receipt.php';
  _wmf_civicrm_update_offline_receipt();
}

/**
 * Update the currency display setting to not have a space between currency &
 * amount.
 *
 * (based on feedback from Leanne on receipt).
 *
 * BUG: T137496
 */
function wmf_civicrm_update_7290() {
  civicrm_initialize();
  civicrm_api3('Setting', 'create', array('moneyformat' => '%c%a'));
}

/**
 * Update custom fields to match fields defined on live.
 *
 * Note that these are generally created on live by non-tech staff
 * (e.g major gifts) and we add them in the script to keep our dev
 * environments in sync.
 *
 * Bug: T147965
 */
function wmf_civicrm_update_7300() {
  require_once 'update_custom_fields.php';
  _wmf_civicrm_update_custom_fields();
}

/**
 * Remove invalid address na@na.com.
 *
 * I put this before update 7305 in case it leaves any contacts without a
 * primary.
 *
 * Only a small number of emails involved.
 *
 * Bug: T149248
 */
function wmf_civicrm_update_7303() {
  civicrm_initialize();
  CRM_Core_DAO::executeQuery('DELETE FROM civicrm_email WHERE email = "na@na.com"');
}

/**
 * Rerun fix for no primary address.
 *
 * I fixed a second cause for this (a rarer one) - make sure
 * all contacts have a primary address.
 *
 * Bug: T145873
 */
function wmf_civicrm_update_7305() {
  wmf_civicrm_update_7250();
}

/**
 * Create and populate a table to geocode US addresses by zip code
 */
function wmf_civicrm_update_7310() {
  civicrm_initialize();
  require_once('update_7310.php');
  _wmf_civicrm_update_7310_add_zip_geo();
}

/**
 * Fix contacts who have no primary address- this has arisen from the dedupes.
 *
 * I did this on emails before and but I just checked and there are around 7000
 * addresses
 *
 * Bug: T143062
 */
function wmf_civicrm_update_7315() {
  civicrm_initialize();
  $entity = 'address';
  CRM_Core_DAO::executeQuery("
    CREATE TEMPORARY TABLE civicrm_{$entity}_updates
     SELECT id FROM
      (
        SELECT contact_id, sum(is_primary) as c, e.id
        FROM civicrm_{$entity} e
        INNER JOIN civicrm_contact c ON c.id = contact_id AND is_deleted = 0
        GROUP BY contact_id HAVING c = 0
      ) as i
  ");

  CRM_Core_DAO::executeQuery("ALTER TABLE civicrm_{$entity}_updates ADD INDEX index_id(id)");
  CRM_Core_DAO::executeQuery("UPDATE civicrm_{$entity} e INNER JOIN civicrm_{$entity}_updates u ON e.id = u.id
    SET e.is_primary = 1
  ");
}

/**
 * Update existing US addresses with latitude, longitude, and time zone
 */
function wmf_civicrm_update_7320() {
  civicrm_initialize();
  CRM_Core_DAO::executeQuery("
    CREATE TEMPORARY TABLE civicrm_address_geocode (
      id INT PRIMARY KEY,
      zip CHAR(64),
      latitude DECIMAL (10,6),
      longitude DECIMAL (10,6),
      timezone VARCHAR(8)
    )");

  CRM_Core_DAO::executeQuery("INSERT INTO civicrm_address_geocode (id, zip)
     SELECT id, LEFT(postal_code, 5)
     FROM civicrm_address
     WHERE country_id = (SELECT id FROM civicrm_country WHERE iso_code = 'US')
  ");

  CRM_Core_DAO::executeQuery("ALTER TABLE civicrm_address_geocode ADD INDEX index_zip(zip)");

  CRM_Core_DAO::executeQuery("
    UPDATE civicrm_address_geocode c
    INNER JOIN wmf_zip_geo g ON c.zip = g.zip
    SET c.latitude = g.latitude,
      c.longitude = g.longitude,
      c.timezone = g.timezone
  ");

  $batch = 100000;
  for ($startId = 0; $startId < 21000000; $startId += $batch) {
    $endId = $startId + $batch;
    CRM_Core_DAO::executeQuery("
      UPDATE civicrm_address a
      INNER JOIN civicrm_address_geocode c ON c.id = a.id
      SET a.geo_code_1 = c.latitude,
        a.geo_code_2 = c.longitude,
        a.timezone = c.timezone
      WHERE a.id BETWEEN $startId AND $endId
    ");
  }
}

/**
 * Backfill gift so that donations of $1000+ have a gift source.
 *
 * These fields have defaults which will have been used if the table is
 * touched at all during the update. As this stage I think we are just filling
 * missing data.
 *
 * T138361
 */
function wmf_civicrm_update_7325() {
  civicrm_initialize();
  $customGroup = civicrm_api3('CustomGroup', 'getsingle', array(
    'name' => 'Gift_Data',
    'return' => 'table_name',
  ));
  $customField = civicrm_api3('CustomField', 'getsingle', array(
    'name' => 'Campaign',
    'return' => 'column_name',
  ));

  CRM_Core_DAO::executeQuery("INSERT INTO {$customGroup['table_name']} (entity_id, {$customField['column_name']})
    SELECT c.id as entity_id, 'Benefactor Gift' as {$customField['column_name']}
    FROM civicrm_contribution c
    LEFT JOIN {$customGroup['table_name']} v ON v.entity_id = c.id
    WHERE c.total_amount >= 1000 AND v.id IS NULL
  ");

}

/**
 * Fix rounding of lat/long caused by DOUBLE wierdness.
 *
 * T150305
 */
function wmf_civicrm_update_7330() {
  civicrm_initialize();
  CRM_Core_DAO::executeQuery("
    UPDATE civicrm_address
    SET geo_code_1 = ROUND(geo_code_1, 6),
    geo_code_2 = ROUND(geo_code_2, 6)
    WHERE geo_code_1 IS NOT NULL;
  ");
}

/**
 * Text updates to the Thank you letter.
 *
 * Bug T151814
 */
function wmf_civicrm_update_7335() {
  require_once 'update_receipt.php';
  _wmf_civicrm_update_offline_receipt();
}

/**
 * Remove review tag.
 *
 * Bug: T118904
 */
function wmf_civicrm_update_7440() {
  civicrm_initialize();
  $tagID = civicrm_api3('Tag', 'getvalue', array(
    'name' => 'Review',
    'return' => 'id',
  ));
  CRM_Core_DAO::executeQuery("
    DELETE FROM civicrm_entity_tag
    WHERE tag_id = $tagID
    AND entity_table = 'civicrm_contact'
  ");
}

/**
 * Re-run fixed geocoding updates
 *
 * Bug: T155677
 */
function wmf_civicrm_update_7450() {
  wmf_civicrm_update_7310();
  wmf_civicrm_update_7320();
}

/**
 * Add index to nick_name column as we have decided to use it for imports.
 *
 * We have decided the Benevity Import should accept org matches on nick_name
 * or organization_name in order to provide the option to refer to them with
 * 2 names. In order to use it it must be indexed. Note that I believe the
 * index size is relative to the number of values in it (currently a few
 * hundred).
 *
 * Bug: T115044
 */
function wmf_civicrm_update_7455() {
  civicrm_initialize();
  $tables = array('civicrm_contact' => array('nick_name'));
  CRM_Core_BAO_SchemaHandler::createIndexes($tables);
}

/**
 * Add index to activity_date_time column.
 *
 * Without this index activities are basically unsearchable as we need to limit
 * them to a time frame to make it manageable.
 *
 * Some performance discussion here.
 *
 * https://issues.civicrm.org/jira/browse/CRM-19821
 */
function wmf_civicrm_update_7460() {
  civicrm_initialize();
  $tables = array('civicrm_activity' => array('activity_date_time'));
  CRM_Core_BAO_SchemaHandler::createIndexes($tables);
}

/**
 * Adjust contribution date on 4 recurring contributions to get past blockage.
 *
 * https://phabricator.wikimedia.org/T159298#3063457
 *
 * T159298
 */
function wmf_civicrm_update_7465() {
  civicrm_initialize();
  CRM_Core_DAO::executeQuery("
    UPDATE civicrm_contribution_recur
    SET next_sched_contribution_date = '2017-04-01'
    WHERE id IN (163431,163364,59477,59458)
    AND next_sched_contribution_date IN ('2017-03-28', '2017-03-27')
  ");
}

/**
 * Re-run geocoding update, many not updated.
 *
 * Bug T158271.
 */
function wmf_civicrm_update_7470() {
  wmf_civicrm_update_7320();
}

/**
 * Create table of all candidates for blank address fixes.
 *
 * We will delete from here as we resolve them.
 *
 * Bug: T159396
 */
function wmf_civicrm_update_7475() {
  civicrm_initialize();
  CRM_Core_DAO::executeQuery(
    "CREATE TABLE IF NOT EXISTS blank_addresses
     SELECT *
     FROM log_civicrm_address
     WHERE street_address IS NULL
     AND city IS NULL
     AND postal_code IS NULL
     AND state_province_id IS NULL
     AND country_id IS NULL
    "
  );
  CRM_Core_DAO::executeQuery(
    "ALTER TABLE blank_addresses ADD INDEX index_id(id), ADD INDEX index_log_action(log_action)"
  );
}

/**
 * Fill in missing first and last names from the sort_name field
 *
 * Bug: T159455
 */
function wmf_civicrm_update_7480() {
  civicrm_initialize();
  // First the easy ones
  CRM_Core_DAO::executeQuery(
    "UPDATE civicrm_contact
		SET last_name = SUBSTRING_INDEX(sort_name, ', ', 1),
			first_name = SUBSTRING_INDEX(sort_name, ', ', -1)
		WHERE created_date BETWEEN '2017-02-28' AND '2017-03-03'
		AND contact_type = 'Individual'
		AND first_name IS NULL
		AND last_name IS NULL
		AND sort_name LIKE '%, %'
    ");
  // Some of the contacts have been touched since creation, and Civi has helpfully
  // destroyed the sort_name. log_civicrm_contact to the rescue!
  CRM_Core_DAO::executeQuery("
create temporary table tmp_T159455
select
    id,
	-- Include null columns as placeholders.
	first_name,
	last_name
from civicrm_contact
where
    created_date between '2017-02-28' and '2017-03-03'
    and contact_type = 'Individual'
    and first_name is null
    and last_name is null
		");

  CRM_Core_DAO::executeQuery("
update tmp_T159455 t
inner join log_civicrm_contact l
    on t.id = l.id
set
    t.last_name = substring_index(l.sort_name, ', ', 1),
    t.first_name = substring_index(l.sort_name, ', ', -1)
where
    l.sort_name like '%, %'
		");

  // Set the names using the API in order to refresh calculations.
  $query = "
		select * from tmp_T159455
		where first_name is not null
			and last_name is not null
	";
  $dao = CRM_Core_DAO::executeQuery($query);
  while ($dao->fetch()) {
    civicrm_api3('Contact', 'create', array(
      'id' => $dao->id,
      'first_name' => $dao->first_name,
      'last_name' => $dao->last_name,
    ));
  }
}

/**
 * Remove blank addresses that were created blank & have not been updated.
 *
 * Bug: T159402
 */
function wmf_civicrm_update_7485() {
  civicrm_initialize();
  $batch = 50000;
  // arbitrary start.
  $count = 1;
  while ($count > 0) {
    CRM_Core_DAO::executeQuery("
    CREATE TABLE blanks_to_go
    SELECT b.id
    FROM blank_addresses b
    INNER JOIN civicrm_address a
      ON a.id = b.id
    LEFT JOIN log_civicrm_address c
      ON c.id = b.id
      AND c.log_action <> b.log_action
      AND c.log_conn_id NOT IN ('" . implode("','", wmf_civicrm_get_log_conn_bulk_update()) . "')
      AND (
        c.contact_id <> b.contact_id
        OR (
          c.city IS NOT NULL
          OR c.postal_code IS NOT NULL
          OR c.state_province_id IS NOT NULL
          OR c.country_id IS NOT NULL
          OR c.street_address IS NOT NULL
        )
      )
    WHERE
      a.street_address IS NULL
      AND a.city IS NULL
      AND a.country_id IS NULL
      AND a.postal_code IS NULL
      AND a.state_province_id IS NULL
      AND b.log_action IN ('Initialization', 'Insert')
      AND c.id IS NULL
      LIMIT $batch
    ");
    $count = CRM_Core_DAO::singleValueQuery('SELECT count(*) FROM blanks_to_go');

    CRM_Core_DAO::executeQuery(
      "DELETE a
       FROM civicrm_address a
       WHERE id IN (
        SELECT b.id
        FROM blanks_to_go b
       )
     "
    );

    CRM_Core_DAO::executeQuery(
      "DELETE a
       FROM blanks_to_go b
       INNER JOIN blank_addresses a ON a.id = b.id
     "
    );

    CRM_Core_DAO::executeQuery(
      "DROP TABLE blanks_to_go"
    );

  }

}

/**
 *
 * Remove obsolete blank address from tracking table.
 *
 * The blank_addresses table tracks blanked addresses. This
 * function removes addresses from that table that were inserted as blanks,
 * later deleted while still blanks and which did not have an updates made.
 *
 * In some cases an update may have been made without adding data. This
 * could involve either fixing the is_primary flag or updating the contact in
 * a merge. However, we know the record has been deleted and never had any
 * retrievable data on it.
 *
 * In other words we don't need to track these as they were fully resolved
 * already.
 *
 * 21590 rows so we don't need to batch.
 *
 * Bug: T159396
 */
function wmf_civicrm_update_7490() {
  civicrm_initialize();
  CRM_Core_DAO::executeQuery("
    CREATE TABLE blanks_to_go
    SELECT i.id
    FROM blank_addresses i
    INNER JOIN blank_addresses d
      ON i.id = d.id
      AND i.log_action  IN ('Insert', 'Initialization')
      AND d.log_action = 'Delete'
    LEFT JOIN log_civicrm_address l
      ON l.id = i.id AND l.log_action = 'Update'
      AND (
       l.country_id IS NOT NULL
       OR l.state_province_id IS NOT NULL
       OR l.street_address IS NOT NULL
       OR l.postal_code IS NOT NULL
       OR l.city IS NOT NULL
      )
      AND l.log_conn_id NOT IN ('" . implode("','", wmf_civicrm_get_log_conn_bulk_update()) . "')
    WHERE l.id IS NULL
    ");

  CRM_Core_DAO::executeQuery(
    "DELETE a
       FROM blanks_to_go b
       INNER JOIN blank_addresses a ON a.id = b.id
     "
  );

  CRM_Core_DAO::executeQuery(
    "DROP TABLE blanks_to_go"
  );

}

/**
 *
 * Remove blank addresses relating to bulk updates from tracking table.
 *
 * There is a small number of addresses (only 130) which were only updated
 * as part of the geocoding updates, some more are affected by primary address
 * fixes
 *
 * . Remove these to be less confusing.
 *
 * Bug: T159396
 */
function wmf_civicrm_update_7495() {
  civicrm_initialize();
  CRM_Core_DAO::executeQuery("
    DELETE FROM blank_addresses WHERE log_conn_id IN (
    '" . implode("','", wmf_civicrm_get_log_conn_bulk_update()) . "')");
}

/**
 * Get the log connection ids for known bulk updates to we can
 * remove them from the update records we are considering.
 *
 * @return array
 */
function wmf_civicrm_get_log_conn_bulk_update() {
  return array(
    // Bulk update on 2017-02-07 involving 11712 records.
    // Consistent with the fix to primary addresses.
    // I committed the relevant fix on
    // commit 7b287e68292da1ae161aa2383808d8925af4a583
    // Author: eileen <emcnaughton@wikimedia.org>
    // Date:   Thu Feb 2 15:41:58 2017 +1300
    '589a35f1e77ec',
    // Buld update on 2016-11-02 involving 4458473 records
    // Consistent with first attempt to add (non-rounded) geocodes.
    //commit e4bf03d321f975a21510337f75e088c235c49521
    // Author: Elliott Eggleston <ejegg@ejegg.com>
    // Date:   Tue Nov 1 14:18:31 2016 -0500
    // Geocode existing US addresses
    '581939a5f3bc8',
    // Bulk update on 2016-11-09 21:28:43 involving 4715708 records
    // consistent with fixing the rounding on prior changes.
    //commit 25558f9b27b2b2d0be17d1dd25e16ff4d0708a96
    // Author: eileen <emcnaughton@wikimedia.org>
    // Date:   Thu Nov 10 10:01:36 2016 +1300
    // Fix rounding of lat/long caused by DOUBLE wierdness.
    // (note I think the commit is in my tz).
    '5823950b11501',
  );

}

/**
 * Add benevity as a financial type for benevity imports.
 *
 * Bug: T115044
 */
function wmf_civicrm_update_7500() {
  civicrm_initialize();
  wmf_civicrm_create_financial_types(array('Benevity'));
}

/**
 * Rerun 7845 & 7490 with a slightly bigger catchment.
 *
 * This means that addresses with updates that only affect bulk updates on
 * things like geocode & is_primary will also be treated as 'non-updated' &
 * removed from the db if blank.
 */
function wmf_civicrm_update_7505() {
  wmf_civicrm_update_7485();
  wmf_civicrm_update_7490();
}

/**
 * Set street address/ postal_code to NULL where placeholder info has been used.
 *
 * Note that all addresses in the DB with N0NE PROVIDED or 0 postal_code have a
 * country_id so this is really precautionary, but we would want to delete the
 * address if it were blank, rather than update it.
 *
 * Bug: T158268
 */
function wmf_civicrm_update_7510() {
  wmf_civicrm_remove_bad_data_from_field('civicrm_address', 'street_address', array('N0NE PROVIDED'));
  wmf_civicrm_remove_bad_data_from_field('civicrm_address', 'postal_code', array('0'));
}

/**
 * Remove bad data from an address field in a batched manner.
 *
 * @param string $tableName
 * @param string $fieldName
 *   Field name to update
 * @param array $fieldValues
 *   Values to strip out.
 */
function wmf_civicrm_remove_bad_data_from_field($tableName, $fieldName, $fieldValues) {

  civicrm_initialize();

  foreach ($fieldValues as $fieldValue) {
    $whereClause = "WHERE $fieldName = '{$fieldValue}'";
    $setClause = "SET a.{$fieldName} = NULL";
    wmf_civicrm_batch_update_data($tableName, $whereClause, $setClause);
  }
}

/**
 * Update civicrm data in batches.
 *
 * @param string $tableName
 *   Name of table to update.
 * @param string string $whereClause
 *   Where clause to apply
 * @param string $setClause
 *   SET clause to apply.
 * @param int $batchSize
 *   Number to process per iteration
 */
function wmf_civicrm_batch_update_data($tableName, $whereClause, $setClause, $batchSize = 10000) {
  $nextId = 1;
  while ($nextId > 0) {
    CRM_Core_DAO::executeQuery("
        CREATE TEMPORARY TABLE {$tableName}_to_update
        SELECT id FROM {$tableName}
        $whereClause
        LIMIT $batchSize
      ");
    CRM_Core_DAO::executeQuery("
        ALTER TABLE {$tableName}_to_update
        ADD INDEX(id)
      ");
    CRM_Core_DAO::executeQuery("
        UPDATE {$tableName}_to_update t
        INNER JOIN {$tableName} a
        ON t.id = a.id
        $setClause
      "
    );
    $nextId = CRM_Core_DAO::singleValueQuery("
        SELECT id
        FROM {$tableName}
        $whereClause
        LIMIT 1
      ");
    CRM_Core_DAO::executeQuery("DROP TEMPORARY TABLE {$tableName}_to_update");
  }
}

/**
 * Backfill contribution_tracking associations for recurring donations
 *
 * Bug: T163443
 */
function wmf_civicrm_update_7520() {
  civicrm_initialize();
  $affected = CRM_Core_DAO::executeQuery("
    SELECT cont.id, ext.gateway_txn_id
    FROM civicrm_contribution cont
    INNER JOIN wmf_contribution_extra ext on ext.entity_id = cont.id
    LEFT JOIN drupal.contribution_tracking ct
    ON ct.contribution_id = cont.id
    WHERE cont.trxn_id LIKE 'RECURRING PAYPAL%'
    AND cont.receive_date > '2017-04-09'
    AND ct.id IS NULL
  ");
  $found = [];
  $logDir = wmf_audit_get_log_archive_dir();
  $lines = array();
  // These lines will have the gateway_trxn_id and the ct_id
  $files = implode(' ', glob("$logDir/fundraising-drupal-201704*"));
  $cmd = "/bin/zgrep subscr_payment $files";
  exec($cmd, $lines);
  foreach ($lines as $line) {
    $parsed = wmf_civicrm_parse_watchdog_array($line);
    if (
      !empty($parsed['gateway_txn_id']) &&
      !empty($parsed['contribution_tracking_id'])
    ) {
      // Normalized lines
      $found[$parsed['gateway_txn_id']] = $parsed['contribution_tracking_id'];
    }
    else {
      if (!empty($parsed['txn_id'])) {
        // Raw PayPal IPNs
        if (
          !empty($parsed['transaction_subject']) &&
          is_numeric($parsed['transaction_subject'])
        ) {
          $found[$parsed['txn_id']] = $parsed['transaction_subject'];
        }
        else {
          if (
            !empty($parsed['custom']) &&
            is_numeric($parsed['custom'])
          ) {
            $found[$parsed['txn_id']] = $parsed['custom'];
          }
        }
      }
    }
  }
  $fixed = 0;
  $missing = 0;
  while ($affected->fetch()) {
    $gatewayTxnId = $affected->gateway_txn_id;
    if (empty($found[$gatewayTxnId])) {
      $missing++;
    }
    else {
      wmf_civicrm_message_update_contribution_tracking(
        array('contribution_tracking_id' => $found[$gatewayTxnId]),
        array('id' => $affected->id)
      );
      $fixed++;
    }
  }
}

/**
 * Normalize old phone numbers
 **/
function wmf_civicrm_update_7522() {
  civicrm_initialize();
  $maxId = CRM_CORE_DAO::singleValueQuery("SELECT max(id) FROM civicrm_phone");
  $batch = 100000;
  for ($startId = 0; $startId < $maxId; $startId += $batch) {
    $endId = $startId + $batch;
    CRM_Core_DAO::executeQuery("
      UPDATE civicrm_phone
      SET phone_numeric = civicrm_strip_non_numeric(phone)
      WHERE id BETWEEN $startId AND $endId
    ");
  }
}

/**
 * Add correct currency symbols
 */
function wmf_civicrm_update_7523() {
  require_once('update_7523.php');
  _wmf_civicrm_update_7523_insert_currency_symbols();
}

/**
 * Add duplicate contribution tag
 */
function wmf_civicrm_update_7524() {
  civicrm_initialize();
  $tag = array(
    'name' => 'DuplicateInvoiceId',
    'used_for' => 'civicrm_contribution',
    'description' => 'Used for contributions where the original assigned invoice id was a duplicate with another already in the database',
    'is_reserved' => 1, //WIP: What does this mean?
    'selectable' => 0,
  );
  civicrm_api3('Tag', 'Create', $tag);
}

/**
 * Enable CiviCampaign.
 */
function wmf_civicrm_update_7525() {
  wmf_civicrm_bootstrap_civi();
  $components = civicrm_api3('Setting', 'getvalue', array(
    'name' => "enable_components",
  ));
  if (isset($components['is_error'])) {
    // weirdness.
    unset($components['is_error']);
  }
  $components[] = 'CiviCampaign';
  civicrm_api3('Setting', 'create', array('enable_components' => $components));
}

/**
 * Add index to name field on civicrm_campaign.
 *
 * Bug: T168499
 */
function wmf_civicrm_update_7526() {
  civicrm_initialize();
  $tables = array('civicrm_campaign' => array('name'));
  CRM_Core_BAO_SchemaHandler::createIndexes($tables);
}

/**
 * Enable Omnimail.
 */
function wmf_civicrm_update_7530() {
  civicrm_initialize();
  // We are looking for the best place to set this dir. Currently on live it is
  // set in civicrm.settings etc. That will override any attempt to set it here.
  civicrm_api3('setting', 'create', array('extensionsDir' => 'sites/default/civicrm/extensions'));
  civicrm_api3('extension', 'refresh', array());
  civicrm_api3('extension', 'install', array('key' => 'org.wikimedia.omnimail'));
  civicrm_api3('extension', 'install', array('key' => 'au.org.greens.extendedmailingstats'));
}

/**
 * Remove void data from city field & tidy name field data.
 */
function wmf_civicrm_update_7540() {
  wmf_civicrm_remove_bad_data_from_field('civicrm_address', 'city', array(
    'city',
    '0',
    'City/Town',
    'NoCity',
  ));
  wmf_civicrm_remove_bad_data_from_field('civicrm_address', 'postal_code', array('0'));
  $replacements = array(
    array(
      // Non breaking space. If we don't sort out these odd spaces
      // first the replace spaces line doesn't work on them & we get an endless loop.
      // Although the LIKE BINARY down further probably now mitigates.
      'find' => "C2A0",
      'replace_with' => ' ',
      'fields' => array('first_name', 'last_name'),
      'is_binary' => TRUE,
      'like_clause' => "BINARY CONCAT('%', unhex('C2A0'), '%')",
    ),
    array(
      // IDEOGRAPHIC SPACE
      // http://www.fileformat.info/info/unicode/char/3000/index.htm
      'find' => "E38080",
      'replace_with' => ' ',
      'fields' => array('first_name', 'last_name'),
      'is_binary' => TRUE,
      'like_clause' => "BINARY CONCAT('%', unhex('E38080'), '%')",
    ),
    array(
      'find' => '  ',
      'replace_with' => ' ',
      'fields' => array('first_name', 'last_name'),
    ),
    array(
      'find' => '&amp;',
      'replace_with' => '&',
      'fields' => array('first_name', 'last_name'),
    ),
    array(
      'find' => '&Amp;',
      'replace_with' => '&',
      'fields' => array('first_name', 'last_name'),
    ),
  );
  foreach ($replacements as $replacement) {
    $likeClause = "'%{$replacement['find']}%'";
    $findString = "'{$replacement['find']}'";
    if (!empty($replacement['is_binary'])) {
      $likeClause = $replacement['like_clause'];
      $findString = "UNHEX('{$replacement['find']}')";
    }
    foreach ($replacement['fields'] as $field) {
      wmf_civicrm_batch_update_data(
        'civicrm_contact',
        "WHERE $field LIKE BINARY $likeClause",
        "SET a.{$field} = REPLACE({$field}, {$findString}, '{$replacement['replace_with']}')"
      );
    }
  }

}

/**
 * Clean up CiviCRM groups.
 *
 * T174407.
 */
function wmf_civicrm_update_7545() {
  // This has now run on live & may not run on people's locals so
  // hack it down now.
  return;
  require_once('update_7545.php');
  _wmf_civicrm_cleanup_groups();
}

/**
 * Add country-only addresses omitted because of T178316
 *
 * Contributions imported between 2017-10-12 19:47 and
 * 2017-10-16 23:39 were affected. IDs were gleaned from
 * donation queue consumer logs.
 */
function wmf_civicrm_update_7550() {
  civicrm_initialize();
  $query = 'SELECT cc.id, cc.contact_id
    FROM civicrm_contribution cc
    LEFT JOIN civicrm_address a on cc.contact_id = a.contact_id
    WHERE a.id IS NULL
    AND cc.id BETWEEN 25045410 AND 25147673';
  $dao = CRM_Core_DAO::executeQuery($query);
  while ($dao->fetch()) {
    $trackingCountry = db_select('contribution_tracking', 'ct')
      ->fields('ct', array('country'))
      ->condition('contribution_id', $dao->id)
      ->execute()
      ->fetchField();
    if (!$trackingCountry) {
      continue;
    }
    $countryId = wmf_civicrm_get_country_id($trackingCountry);
    if (!$countryId) {
      continue;
    }
    civicrm_api3(
      'Address',
      'create',
      array(
        'contact_id' => $dao->contact_id,
        'country_id' => $countryId,
        'location_type_id' => 1,
      )
    );
  }
}

/**
 * Fix contacts with two primary addresses
 */
function wmf_civicrm_update_7560() {
  civicrm_initialize();
  $query = 'SELECT contact_id
    FROM civicrm_address
    WHERE is_primary=1
    AND contact_id IS NOT NULL
    GROUP BY contact_id
    HAVING COUNT(*) > 1';
  $contactIds = CRM_Core_DAO::executeQuery($query);
  while ($contactIds->fetch()) {
    $addresses = civicrm_api3(
      'Address',
      'get',
      array(
        'contact_id' => $contactIds->contact_id,
        'is_primary' => 1,
      )
    );
    $bestAddress = NULL;
    $addressesToDelete = array();
    $addressesToDemote = array();
    foreach ($addresses['values'] as $address) {
      if ($bestAddress === NULL) {
        $bestAddress = $address;
      }
      else {
        if (_wmf_civicrm_is_this_address_better($address, $bestAddress)) {
          // previous best address is a subset of current address
          $addressesToDelete[] = $bestAddress;
          $bestAddress = $address;
        }
        elseif (_wmf_civicrm_is_this_address_better($bestAddress, $address)) {
          // current address is a subset of previous best address
          $addressesToDelete[] = $address;
        }
        elseif ($address['id'] > $bestAddress['id']) {
          // neither is a subset, current is newer than previous best
          $addressesToDemote[] = $bestAddress;
          $bestAddress = $address;
        }
        else {
          // neither is a subset, previous best is newer
          $addressesToDemote[] = $address;
        }
      }
    }
    foreach ($addressesToDelete as $deleteMe) {
      civicrm_api3('Address', 'delete', array('id' => $deleteMe['id']));
    }
    foreach ($addressesToDemote as $demoteMe) {
      $dao = _civicrm_api3_load_DAO('Address');
      $dao->id = $demoteMe['id'];
      $dao->is_primary = 0;
      $dao->update();
    }
  }
}

/*
 * Update Contact Deleted by Merge activies
 */
function wmf_civicrm_update_7565() {
  civicrm_initialize();
  $batch = 100;
  $maxId = CRM_Core_DAO::singleValueQuery("SELECT max(id) FROM civicrm_activity");
  $activity_type_id = civicrm_api3('OptionValue', 'getSingle', array(
    'label' => 'Contact Deleted by Merge',
    'return' => 'value',
  ));
  $query = "SELECT ca.id as activity_id, cap.contact_id as new_contact_id
             FROM civicrm_activity ca
             JOIN civicrm_activity_contact cap ON ca.parent_id=cap.activity_id AND cap.record_type_id=3
             WHERE (SELECT count(*) FROM civicrm_activity_contact WHERE record_type_id=1 AND activity_id=ca.id)=0
             AND ca.activity_type_id=%1 AND ca.id BETWEEN %2 AND %3";
  $params = array(1 => array($activity_type_id['value'], 'Integer'));
  for ($startId = 0; $startId < $maxId; $startId += $batch) {
    $endId = $startId + $batch;
    $params[2] = array($startId, 'Integer');
    $params[3] = array($endId, 'Integer');
    $activities = CRM_Core_DAO::executeQuery($query, $params);
    while ($activities->fetch()) {
      civicrm_api3('ActivityContact', 'create', array(
        'activity_id' => $activities->activity_id,
        'contact_id' => $activities->new_contact_id,
        'record_type_id' => 1,
      ));
    }
  }
}

/**
 * Tidy up our dedupe rules.
 */
function wmf_civicrm_update_7570() {
  civicrm_initialize();
  CRM_Core_DAO::executeQuery("UPDATE civicrm_dedupe_rule_group SET name = 'IndividualSupervised' WHERE name = 'Kaldari Rule-9'");
  // This didn't cascade right in single query so 2 deletes.
  CRM_Core_DAO::executeQuery("DELETE r FROM civicrm_dedupe_rule_group rg LEFT JOIN civicrm_dedupe_rule r ON r.dedupe_rule_group_id = rg.id WHERE name = 'IndividualSupervised2_14'");
  CRM_Core_DAO::executeQuery("DELETE FROM civicrm_dedupe_rule_group WHERE name = 'IndividualSupervised2_14'");

  $generalRules = CRM_Core_DAO::singleValueQuery(
    "SELECT count(*) FROM civicrm_dedupe_rule_group WHERE used = 'General' AND is_reserved = 1 AND contact_type = 'Individual'"
  );
  if ($generalRules > 1) {
    // Otherwise we are probably on someone's dev environment. Goal here is to remove duff data from prod not mess with people (much).
    CRM_Core_DAO::executeQuery("
      DELETE r FROM civicrm_dedupe_rule_group rg
      LEFT JOIN civicrm_dedupe_rule r ON r.dedupe_rule_group_id = rg.id
      WHERE used = 'General' AND is_reserved = 1 AND contact_type = 'Individual' AND rg.id IN(10,11)
    ");
    CRM_Core_DAO::executeQuery("
      DELETE FROM civicrm_dedupe_rule_group
      WHERE used = 'General' AND is_reserved = 1 AND contact_type = 'Individual' AND id IN(10,11)
    ");
  }

  // Create a new rule group that will catch a broad range of contacts (but should only be
  // used against a narrow one for performance reasons.
  // This is to help major gifts pull up a screen of possible matches rather than
  // trawling for them.
  //
  // Struggling to think of a precise name / description so going for something
  // people should remember. Am tempted to add a 'Go Fish' button to contact dash now.
  // This rule is set up on staging and can be accessed from a contact record
  // under the drop down actions. I tried it on a few fairly common names (John Smith)
  // and there was some lag in those cases but not that bad & certainly better than doing searches.
  $ruleGroup = civicrm_api3('RuleGroup', 'create', array(
    'name' => 'fishing_net',
    'title' => 'Fishing Net',
    'contact_type' => 'Individual',
    'used' => 'General',
    'threshold' => 150,
  ));

  $queryStart = "INSERT INTO civicrm_dedupe_rule (dedupe_rule_group_id, rule_table, rule_field, rule_weight) VALUES ({$ruleGroup['id']}, ";

  // Only 5 rule-criteria can be configured in the UI but more will work if added.
  // An email match alone is enough to hit the threshold.
  CRM_Core_DAO::executeQuery($queryStart . "'civicrm_email', 'email', 150 )");

  // Last name is enough if the street address is the same OR the
  // first name is the same too and either state or city is the same.
  // There are some odd street address ones -
  CRM_Core_DAO::executeQuery($queryStart . "'civicrm_contact', 'last_name', 120 )");
  CRM_Core_DAO::executeQuery($queryStart . "'civicrm_contact', 'first_name', 25 )");
  CRM_Core_DAO::executeQuery($queryStart . "'civicrm_address', 'street_address', 30 )");
  CRM_Core_DAO::executeQuery($queryStart . "'civicrm_address', 'city', 10 )");
  CRM_Core_DAO::executeQuery($queryStart . "'civicrm_address', 'state_province_id', 5 )");
}

/**
 * Enable dedupe tools.
 *
 * This extension is intended to be where our custom dedupe code gets
 * transferred to.
 *
 * Bug: T177999
 */
function wmf_civicrm_update_7575() {
  civicrm_initialize();
  civicrm_api3('extension', 'refresh', array());
  civicrm_api3('extension', 'install', array('key' => 'org.wikimedia.dedupetools'));
}

/**
 * Enable extended report.
 *
 * This extension gives us the Address History tab.
 *
 * Bug: T142549
 */
function wmf_civicrm_update_7580() {
  civicrm_initialize();
  civicrm_api3('extension', 'refresh', array());
  civicrm_api3('extension', 'install', array('key' => 'nz.co.fuzion.extendedreport'));
}

/**
 * Add report for Address History tab.
 *
 * Bug: T142549
 */
function wmf_civicrm_update_7585() {
  civicrm_initialize();
  civicrm_api3('ReportInstance', 'create', array(
    'title' => ts('Address History'),
    'report_id' => 'contact/addresshistory',
    'description' => 'ContactAddress History',
    'permission' => 'access CiviReport',
    'form_values' => serialize(array(
      'fields' => array(
        'address_display_address' => 1,
        'log_date' => 1,
        'address_location_type_id' => 1,
        'address_is_primary' => 1,
        'log_conn_id' => 1,
        'log_user_id' => 1,
        'log_action' => 1,
      ),
      'contact_dashboard_tab' => array('contact_dashboard_tab' => '1'),
    )),
  ));
}

/**
 * Add Stripe payment instrument
 */
function wmf_civicrm_update_7595() {
  require_once 'update_payment_instruments.php';
  wmf_install_add_missing_payment_instruments();
}

/**
 * Re-save any contacts without a display name.
 *
 * Doing a blank re-save will cause the display name to be recalculated by Civi
 * rules.
 *
 * Not useful here but possibly for Major Gifts letter addressing it also
 * will allow us to update addressing fields (e.g Dear Fred) for sending letters.
 * We don't do that for all contacts but could for MG.
 *
 * Bug: T179118
 */
function wmf_civicrm_update_7600() {
  civicrm_initialize();
  $result = CRM_Core_DAO::executeQuery(
    "SELECT id FROM civicrm_contact WHERE (display_name is null  OR display_name = '') AND is_deleted= 0"
  );
  while ($result->fetch()) {
    civicrm_api3('Contact', 'create', array('id' => $result->id));
  }
}

/**
 * Add contact type editor extension.
 *
 * Bug: TT156193
 */
function wmf_civicrm_update_7605() {
  civicrm_initialize();
  civicrm_api3('extension', 'refresh', array());
  civicrm_api3('extension', 'install', array('key' => 'org.wikimedia.contacteditor'));
}

/**
 * Add civitoken extension.
 *
 * We want the formatted address blocks from here.
 *
 * We disable most of the others to keep things clean.
 *
 * Bug: T184647
 */
function wmf_civicrm_update_7610() {
  civicrm_initialize();
  civicrm_api3('extension', 'refresh', array());
  civicrm_api3('extension', 'install', array('key' => 'nz.co.fuzion.civitoken'));
  civicrm_api3('Setting', 'create', array('civitoken_enabled_tokens' => array(
    'address.address_block',
    'address.address_text',
    'address.conditional_country',
    'date.today_format_full',
    'date.today_format_raw',
  )));
}

/**
 * Add geocoder extension.
 *
 * Disable geocoders we don't want.
 *
 * Bug: T184830
 */
function wmf_civicrm_update_7615() {
  civicrm_initialize();
  civicrm_api3('extension', 'refresh', array());
  civicrm_api3('extension', 'install', array('key' => 'org.wikimedia.geocoder'));
  wmf_civicrm_ensure_correct_geocoder_enabled();
}
